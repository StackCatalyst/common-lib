
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/StackCatalyst/common-lib/pkg/auth/config.go (100.0%)</option>
				
				<option value="file1">github.com/StackCatalyst/common-lib/pkg/auth/config_integration.go (82.5%)</option>
				
				<option value="file2">github.com/StackCatalyst/common-lib/pkg/auth/errors.go (90.2%)</option>
				
				<option value="file3">github.com/StackCatalyst/common-lib/pkg/auth/interceptors.go (93.6%)</option>
				
				<option value="file4">github.com/StackCatalyst/common-lib/pkg/auth/jwt.go (75.5%)</option>
				
				<option value="file5">github.com/StackCatalyst/common-lib/pkg/auth/logging.go (76.6%)</option>
				
				<option value="file6">github.com/StackCatalyst/common-lib/pkg/auth/metrics.go (100.0%)</option>
				
				<option value="file7">github.com/StackCatalyst/common-lib/pkg/auth/middleware.go (90.7%)</option>
				
				<option value="file8">github.com/StackCatalyst/common-lib/pkg/auth/rbac.go (90.4%)</option>
				
				<option value="file9">github.com/StackCatalyst/common-lib/pkg/cache/cache.go (87.2%)</option>
				
				<option value="file10">github.com/StackCatalyst/common-lib/pkg/config/config.go (70.0%)</option>
				
				<option value="file11">github.com/StackCatalyst/common-lib/pkg/database/client.go (45.2%)</option>
				
				<option value="file12">github.com/StackCatalyst/common-lib/pkg/database/metrics.go (100.0%)</option>
				
				<option value="file13">github.com/StackCatalyst/common-lib/pkg/errors/advanced.go (88.9%)</option>
				
				<option value="file14">github.com/StackCatalyst/common-lib/pkg/errors/errors.go (90.0%)</option>
				
				<option value="file15">github.com/StackCatalyst/common-lib/pkg/grpc/client.go (59.3%)</option>
				
				<option value="file16">github.com/StackCatalyst/common-lib/pkg/grpc/metrics.go (100.0%)</option>
				
				<option value="file17">github.com/StackCatalyst/common-lib/pkg/http/client.go (88.6%)</option>
				
				<option value="file18">github.com/StackCatalyst/common-lib/pkg/http/metrics.go (100.0%)</option>
				
				<option value="file19">github.com/StackCatalyst/common-lib/pkg/logging/advanced.go (90.7%)</option>
				
				<option value="file20">github.com/StackCatalyst/common-lib/pkg/logging/logger.go (76.9%)</option>
				
				<option value="file21">github.com/StackCatalyst/common-lib/pkg/logging/testing/logger.go (100.0%)</option>
				
				<option value="file22">github.com/StackCatalyst/common-lib/pkg/metrics/advanced.go (78.4%)</option>
				
				<option value="file23">github.com/StackCatalyst/common-lib/pkg/metrics/collector.go (0.0%)</option>
				
				<option value="file24">github.com/StackCatalyst/common-lib/pkg/metrics/metrics.go (88.9%)</option>
				
				<option value="file25">github.com/StackCatalyst/common-lib/pkg/metrics/standard.go (0.0%)</option>
				
				<option value="file26">github.com/StackCatalyst/common-lib/pkg/module/docs/generator.go (85.7%)</option>
				
				<option value="file27">github.com/StackCatalyst/common-lib/pkg/module/storage/postgres/postgres.go (0.0%)</option>
				
				<option value="file28">github.com/StackCatalyst/common-lib/pkg/module/storage/storage.go (100.0%)</option>
				
				<option value="file29">github.com/StackCatalyst/common-lib/pkg/module/testing/assertion.go (76.3%)</option>
				
				<option value="file30">github.com/StackCatalyst/common-lib/pkg/module/testing/mock.go (84.3%)</option>
				
				<option value="file31">github.com/StackCatalyst/common-lib/pkg/module/testing/testing.go (80.7%)</option>
				
				<option value="file32">github.com/StackCatalyst/common-lib/pkg/module/validation/dependency.go (93.3%)</option>
				
				<option value="file33">github.com/StackCatalyst/common-lib/pkg/module/validation/resource.go (100.0%)</option>
				
				<option value="file34">github.com/StackCatalyst/common-lib/pkg/module/validation/schema.go (95.6%)</option>
				
				<option value="file35">github.com/StackCatalyst/common-lib/pkg/module/validation/validation.go (85.7%)</option>
				
				<option value="file36">github.com/StackCatalyst/common-lib/pkg/module/version/version.go (92.5%)</option>
				
				<option value="file37">github.com/StackCatalyst/common-lib/pkg/testing/container.go (95.7%)</option>
				
				<option value="file38">github.com/StackCatalyst/common-lib/pkg/testing/helper.go (100.0%)</option>
				
				<option value="file39">github.com/StackCatalyst/common-lib/pkg/tracing/middleware.go (97.1%)</option>
				
				<option value="file40">github.com/StackCatalyst/common-lib/pkg/tracing/tracer.go (81.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import "time"

// Config holds authentication configuration settings
type Config struct {
        // Token settings
        Token struct {
                // AccessTokenDuration is the duration for which access tokens are valid
                AccessTokenDuration time.Duration `json:"access_token_duration" yaml:"access_token_duration"`
                // RefreshTokenDuration is the duration for which refresh tokens are valid
                RefreshTokenDuration time.Duration `json:"refresh_token_duration" yaml:"refresh_token_duration"`
                // AccessTokenSecret is the secret used to sign access tokens
                AccessTokenSecret string `json:"access_token_secret" yaml:"access_token_secret"`
                // RefreshTokenSecret is the secret used to sign refresh tokens
                RefreshTokenSecret string `json:"refresh_token_secret" yaml:"refresh_token_secret"`
        } `json:"token" yaml:"token"`

        // RBAC settings
        RBAC struct {
                // DefaultRole is the role assigned to new users
                DefaultRole string `json:"default_role" yaml:"default_role"`
                // SuperAdminRole is the role with all permissions
                SuperAdminRole string `json:"super_admin_role" yaml:"super_admin_role"`
                // RoleHierarchy defines the hierarchy of roles (higher roles inherit lower roles' permissions)
                RoleHierarchy map[string][]string `json:"role_hierarchy" yaml:"role_hierarchy"`
        } `json:"rbac" yaml:"rbac"`

        // Rate limiting settings
        RateLimit struct {
                // Enabled indicates whether rate limiting is enabled
                Enabled bool `json:"enabled" yaml:"enabled"`
                // RequestsPerSecond is the maximum number of requests allowed per second
                RequestsPerSecond int `json:"requests_per_second" yaml:"requests_per_second"`
                // BurstSize is the maximum number of requests allowed to burst
                BurstSize int `json:"burst_size" yaml:"burst_size"`
        } `json:"rate_limit" yaml:"rate_limit"`
}

// DefaultConfig returns the default authentication configuration
func DefaultConfig() Config <span class="cov9" title="18">{
        cfg := Config{}

        // Token defaults
        cfg.Token.AccessTokenDuration = 15 * time.Minute
        cfg.Token.RefreshTokenDuration = 24 * time.Hour
        cfg.Token.AccessTokenSecret = ""  // Must be provided
        cfg.Token.RefreshTokenSecret = "" // Must be provided

        // RBAC defaults
        cfg.RBAC.DefaultRole = "user"
        cfg.RBAC.SuperAdminRole = "admin"
        cfg.RBAC.RoleHierarchy = map[string][]string{
                "admin": {"user"},
                "user":  {},
        }

        // Rate limiting defaults
        cfg.RateLimit.Enabled = true
        cfg.RateLimit.RequestsPerSecond = 10
        cfg.RateLimit.BurstSize = 20

        return cfg
}</span>

// Validate validates the authentication configuration
func (c *Config) Validate() error <span class="cov10" title="25">{
        if c.Token.AccessTokenDuration &lt;= 0 </span><span class="cov4" title="4">{
                return newInvalidConfigError("access token duration must be positive")
        }</span>
        <span class="cov9" title="21">if c.Token.RefreshTokenDuration &lt;= 0 </span><span class="cov1" title="1">{
                return newInvalidConfigError("refresh token duration must be positive")
        }</span>
        <span class="cov9" title="20">if c.Token.AccessTokenSecret == "" </span><span class="cov1" title="1">{
                return newInvalidConfigError("access token secret must be provided")
        }</span>
        <span class="cov9" title="19">if c.Token.RefreshTokenSecret == "" </span><span class="cov1" title="1">{
                return newInvalidConfigError("refresh token secret must be provided")
        }</span>
        <span class="cov9" title="18">if c.RBAC.DefaultRole == "" </span><span class="cov1" title="1">{
                return newInvalidConfigError("default role must be provided")
        }</span>
        <span class="cov8" title="17">if c.RBAC.SuperAdminRole == "" </span><span class="cov1" title="1">{
                return newInvalidConfigError("super admin role must be provided")
        }</span>
        <span class="cov8" title="16">if c.RateLimit.Enabled </span><span class="cov7" title="11">{
                if c.RateLimit.RequestsPerSecond &lt;= 0 </span><span class="cov1" title="1">{
                        return newInvalidConfigError("requests per second must be positive")
                }</span>
                <span class="cov7" title="10">if c.RateLimit.BurstSize &lt;= 0 </span><span class="cov1" title="1">{
                        return newInvalidConfigError("burst size must be positive")
                }</span>
        }
        <span class="cov8" title="14">return nil</span>
}

// newInvalidConfigError creates a new error for invalid configuration
func newInvalidConfigError(msg string) error <span class="cov7" title="11">{
        return newInvalidActionError("invalid configuration: " + msg)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "fmt"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/config"
)

const (
        // Configuration keys
        configKeyTokenAccessDuration  = "auth.token.access_duration"
        configKeyTokenRefreshDuration = "auth.token.refresh_duration"
        configKeyTokenAccessSecret    = "auth.token.access_secret"
        configKeyTokenRefreshSecret   = "auth.token.refresh_secret"
        configKeyRBACDefaultRole      = "auth.rbac.default_role"
        configKeyRBACSuperAdminRole   = "auth.rbac.super_admin_role"
        configKeyRBACRoleHierarchy    = "auth.rbac.role_hierarchy"
        configKeyRateLimitEnabled     = "auth.rate_limit.enabled"
        configKeyRateLimitRPS         = "auth.rate_limit.requests_per_second"
        configKeyRateLimitBurst       = "auth.rate_limit.burst_size"
)

// LoadConfig loads the authentication configuration from the config manager
func LoadConfig(cm *config.Manager) (Config, error) <span class="cov7" title="4">{
        var cfg Config

        // Token settings
        cfg.Token.AccessTokenDuration = cm.GetDuration(configKeyTokenAccessDuration)
        if cfg.Token.AccessTokenDuration == 0 </span><span class="cov0" title="0">{
                cfg.Token.AccessTokenDuration = 15 * time.Minute // Default value
        }</span>

        <span class="cov7" title="4">cfg.Token.RefreshTokenDuration = cm.GetDuration(configKeyTokenRefreshDuration)
        if cfg.Token.RefreshTokenDuration == 0 </span><span class="cov0" title="0">{
                cfg.Token.RefreshTokenDuration = 24 * time.Hour // Default value
        }</span>

        <span class="cov7" title="4">cfg.Token.AccessTokenSecret = cm.GetString(configKeyTokenAccessSecret)
        cfg.Token.RefreshTokenSecret = cm.GetString(configKeyTokenRefreshSecret)

        // RBAC settings
        cfg.RBAC.DefaultRole = cm.GetString(configKeyRBACDefaultRole)
        if cfg.RBAC.DefaultRole == "" </span><span class="cov0" title="0">{
                cfg.RBAC.DefaultRole = "user" // Default value
        }</span>

        <span class="cov7" title="4">cfg.RBAC.SuperAdminRole = cm.GetString(configKeyRBACSuperAdminRole)
        if cfg.RBAC.SuperAdminRole == "" </span><span class="cov0" title="0">{
                cfg.RBAC.SuperAdminRole = "admin" // Default value
        }</span>

        // Role hierarchy
        <span class="cov7" title="4">hierarchyMap := cm.GetStringMap(configKeyRBACRoleHierarchy)
        if len(hierarchyMap) == 0 </span><span class="cov0" title="0">{
                // Default hierarchy
                cfg.RBAC.RoleHierarchy = map[string][]string{
                        "admin": {"user"},
                        "user":  {},
                }
        }</span> else<span class="cov7" title="4"> {
                cfg.RBAC.RoleHierarchy = make(map[string][]string)
                for role, parents := range hierarchyMap </span><span class="cov10" title="7">{
                        switch v := parents.(type) </span>{
                        case []interface{}:<span class="cov7" title="4">
                                parentRoles := make([]string, 0, len(v))
                                for _, p := range v </span><span class="cov4" title="2">{
                                        if str, ok := p.(string); ok </span><span class="cov4" title="2">{
                                                parentRoles = append(parentRoles, str)
                                        }</span>
                                }
                                <span class="cov7" title="4">cfg.RBAC.RoleHierarchy[role] = parentRoles</span>
                        case []string:<span class="cov4" title="2">
                                cfg.RBAC.RoleHierarchy[role] = v</span>
                        default:<span class="cov1" title="1">
                                return cfg, fmt.Errorf("invalid role hierarchy format for role %s", role)</span>
                        }
                }
        }

        // Rate limiting settings
        <span class="cov6" title="3">cfg.RateLimit.Enabled = cm.GetBool(configKeyRateLimitEnabled)
        if cfg.RateLimit.Enabled </span><span class="cov4" title="2">{
                cfg.RateLimit.Enabled = true // Default value
        }</span>

        <span class="cov6" title="3">cfg.RateLimit.RequestsPerSecond = cm.GetInt(configKeyRateLimitRPS)
        if cfg.RateLimit.RequestsPerSecond == 0 </span><span class="cov0" title="0">{
                cfg.RateLimit.RequestsPerSecond = 10 // Default value
        }</span>

        <span class="cov6" title="3">cfg.RateLimit.BurstSize = cm.GetInt(configKeyRateLimitBurst)
        if cfg.RateLimit.BurstSize == 0 </span><span class="cov0" title="0">{
                cfg.RateLimit.BurstSize = 20 // Default value
        }</span>

        // Validate the loaded configuration
        <span class="cov6" title="3">if err := cfg.Validate(); err != nil </span><span class="cov1" title="1">{
                return cfg, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov4" title="2">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "errors"

        liberrors "github.com/StackCatalyst/common-lib/pkg/errors"
)

// Auth-specific error codes
const (
        ErrInvalidToken     liberrors.ErrorCode = "INVALID_TOKEN"
        ErrTokenExpired     liberrors.ErrorCode = "TOKEN_EXPIRED"
        ErrMissingToken     liberrors.ErrorCode = "MISSING_TOKEN"
        ErrInvalidRole      liberrors.ErrorCode = "INVALID_ROLE"
        ErrInvalidResource  liberrors.ErrorCode = "INVALID_RESOURCE"
        ErrInvalidAction    liberrors.ErrorCode = "INVALID_ACTION"
        ErrPermissionDenied liberrors.ErrorCode = "PERMISSION_DENIED"
)

// Common error creation functions
func newInvalidTokenError(msg string) error <span class="cov6" title="4">{
        return liberrors.New(ErrInvalidToken, msg)
}</span>

func newTokenExpiredError() error <span class="cov1" title="1">{
        return liberrors.New(ErrTokenExpired, "token has expired")
}</span>

func newMissingTokenError() error <span class="cov1" title="1">{
        return liberrors.New(ErrMissingToken, "authentication token is missing")
}</span>

func newInvalidRoleError(role string) error <span class="cov4" title="3">{
        return liberrors.New(ErrInvalidRole, "invalid role: "+role)
}</span>

func newInvalidResourceError(resource string) error <span class="cov1" title="1">{
        return liberrors.New(ErrInvalidResource, "invalid resource: "+resource)
}</span>

func newInvalidActionError(action string) error <span class="cov10" title="12">{
        return liberrors.New(ErrInvalidAction, "invalid action: "+action)
}</span>

func newPermissionDeniedError(msg string) error <span class="cov1" title="1">{
        return liberrors.New(ErrPermissionDenied, msg)
}</span>

// Error wrapping functions
func wrapTokenError(err error, msg string) error <span class="cov1" title="1">{
        return liberrors.Wrap(err, ErrInvalidToken, msg)
}</span>

func wrapAuthorizationError(err error, msg string) error <span class="cov1" title="1">{
        return liberrors.Wrap(err, ErrPermissionDenied, msg)
}</span>

// Error checking functions
func IsInvalidTokenError(err error) bool <span class="cov6" title="4">{
        var appErr *liberrors.AppError
        for err != nil </span><span class="cov6" title="4">{
                if errors.As(err, &amp;appErr) &amp;&amp; appErr.Code == ErrInvalidToken </span><span class="cov4" title="3">{
                        return true
                }</span>
                <span class="cov1" title="1">err = errors.Unwrap(err)</span>
        }
        <span class="cov1" title="1">return false</span>
}

func IsTokenExpiredError(err error) bool <span class="cov4" title="3">{
        var appErr *liberrors.AppError
        for err != nil </span><span class="cov4" title="3">{
                if errors.As(err, &amp;appErr) &amp;&amp; appErr.Code == ErrTokenExpired </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov3" title="2">err = errors.Unwrap(err)</span>
        }
        <span class="cov3" title="2">return false</span>
}

func IsMissingTokenError(err error) bool <span class="cov3" title="2">{
        var appErr *liberrors.AppError
        for err != nil </span><span class="cov1" title="1">{
                if errors.As(err, &amp;appErr) &amp;&amp; appErr.Code == ErrMissingToken </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
        <span class="cov1" title="1">return false</span>
}

func IsInvalidRoleError(err error) bool <span class="cov3" title="2">{
        var appErr *liberrors.AppError
        for err != nil </span><span class="cov1" title="1">{
                if errors.As(err, &amp;appErr) &amp;&amp; appErr.Code == ErrInvalidRole </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
        <span class="cov1" title="1">return false</span>
}

func IsInvalidResourceError(err error) bool <span class="cov3" title="2">{
        var appErr *liberrors.AppError
        for err != nil </span><span class="cov1" title="1">{
                if errors.As(err, &amp;appErr) &amp;&amp; appErr.Code == ErrInvalidResource </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
        <span class="cov1" title="1">return false</span>
}

func IsInvalidActionError(err error) bool <span class="cov3" title="2">{
        var appErr *liberrors.AppError
        for err != nil </span><span class="cov1" title="1">{
                if errors.As(err, &amp;appErr) &amp;&amp; appErr.Code == ErrInvalidAction </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
        <span class="cov1" title="1">return false</span>
}

func IsPermissionDeniedError(err error) bool <span class="cov4" title="3">{
        var appErr *liberrors.AppError
        for err != nil </span><span class="cov3" title="2">{
                if errors.As(err, &amp;appErr) &amp;&amp; appErr.Code == ErrPermissionDenied </span><span class="cov3" title="2">{
                        return true
                }</span>
                <span class="cov0" title="0">err = errors.Unwrap(err)</span>
        }
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "context"
        "strings"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// AuthUnaryInterceptor creates a gRPC unary interceptor for JWT authentication
func AuthUnaryInterceptor(tm *TokenManager) grpc.UnaryServerInterceptor <span class="cov6" title="4">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="6">{
                // Extract token from metadata
                token, err := extractToken(ctx)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                // Validate token
                <span class="cov7" title="5">claims, err := tm.ValidateAccessToken(token)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.Unauthenticated, "invalid token: %v", err)
                }</span>

                // Add claims to context
                <span class="cov6" title="4">newCtx := context.WithValue(ctx, UserIDKey, claims.UserID)
                newCtx = context.WithValue(newCtx, UserRolesKey, claims.Roles)

                return handler(newCtx, req)</span>
        }
}

// RBACUnaryInterceptor creates a gRPC unary interceptor for RBAC
func RBACUnaryInterceptor(rbac *RBAC, resource Resource, action Action) grpc.UnaryServerInterceptor <span class="cov6" title="4">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="6">{
                roles, err := GetUserRoles(ctx)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, status.Errorf(codes.Unauthenticated, "missing user roles: %v", err)
                }</span>

                <span class="cov7" title="5">if !rbac.IsAllowed(roles, resource, action) </span><span class="cov3" title="2">{
                        return nil, status.Error(codes.PermissionDenied, "insufficient permissions")
                }</span>

                <span class="cov5" title="3">return handler(ctx, req)</span>
        }
}

// AuthStreamInterceptor creates a gRPC stream interceptor for JWT authentication
func AuthStreamInterceptor(tm *TokenManager) grpc.StreamServerInterceptor <span class="cov3" title="2">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov5" title="3">{
                // Extract token from metadata
                token, err := extractToken(ss.Context())
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                // Validate token
                <span class="cov3" title="2">claims, err := tm.ValidateAccessToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Unauthenticated, "invalid token: %v", err)
                }</span>

                // Create new context with claims
                <span class="cov3" title="2">newCtx := context.WithValue(ss.Context(), UserIDKey, claims.UserID)
                newCtx = context.WithValue(newCtx, UserRolesKey, claims.Roles)

                // Wrap ServerStream to use new context
                wrappedStream := &amp;wrappedServerStream{
                        ServerStream: ss,
                        ctx:          newCtx,
                }

                return handler(srv, wrappedStream)</span>
        }
}

// RBACStreamInterceptor creates a gRPC stream interceptor for RBAC
func RBACStreamInterceptor(rbac *RBAC, resource Resource, action Action) grpc.StreamServerInterceptor <span class="cov3" title="2">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov6" title="4">{
                roles, err := GetUserRoles(ss.Context())
                if err != nil </span><span class="cov1" title="1">{
                        return status.Errorf(codes.Unauthenticated, "missing user roles: %v", err)
                }</span>

                <span class="cov5" title="3">if !rbac.IsAllowed(roles, resource, action) </span><span class="cov1" title="1">{
                        return status.Error(codes.PermissionDenied, "insufficient permissions")
                }</span>

                <span class="cov3" title="2">return handler(srv, ss)</span>
        }
}

// wrappedServerStream wraps grpc.ServerStream to modify context
type wrappedServerStream struct {
        grpc.ServerStream
        ctx context.Context
}

func (w *wrappedServerStream) Context() context.Context <span class="cov6" title="4">{
        return w.ctx
}</span>

// extractToken extracts JWT token from gRPC metadata
func extractToken(ctx context.Context) (string, error) <span class="cov10" title="9">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov3" title="2">{
                return "", status.Error(codes.Unauthenticated, "missing metadata")
        }</span>

        <span class="cov8" title="7">values := md.Get("authorization")
        if len(values) == 0 </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "missing authorization header")
        }</span>

        <span class="cov8" title="7">authHeader := values[0]
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != BearerSchema </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "invalid authorization format")
        }</span>

        <span class="cov8" title="7">return parts[1], nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "fmt"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/golang-jwt/jwt/v5"
)

// TokenType represents the type of token
type TokenType string

const (
        // AccessToken is used for API access
        AccessToken TokenType = "access"
        // RefreshToken is used to obtain new access tokens
        RefreshToken TokenType = "refresh"
)

// Claims represents the claims in a JWT token
type Claims struct {
        jwt.RegisteredClaims
        UserID    string    `json:"uid"`
        Roles     []string  `json:"roles"`
        TokenType TokenType `json:"type"`
}

// TokenManager handles JWT token operations
type TokenManager struct {
        config  Config
        metrics *MetricsReporter
}

// NewTokenManager creates a new token manager
func NewTokenManager(config Config, metricsReporter *metrics.Reporter) (*TokenManager, error) <span class="cov8" title="12">{
        if err := config.Validate(); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov7" title="10">return &amp;TokenManager{
                config:  config,
                metrics: NewMetricsReporter(metricsReporter),
        }, nil</span>
}

// generateToken creates a new JWT token
func (tm *TokenManager) generateToken(userID string, roles []string, tokenType TokenType) (string, error) <span class="cov9" title="15">{
        start := time.Now()
        var secret string
        var duration time.Duration

        switch tokenType </span>{
        case AccessToken:<span class="cov8" title="13">
                secret = tm.config.Token.AccessTokenSecret
                duration = tm.config.Token.AccessTokenDuration</span>
        case RefreshToken:<span class="cov3" title="2">
                secret = tm.config.Token.RefreshTokenSecret
                duration = tm.config.Token.RefreshTokenDuration</span>
        default:<span class="cov0" title="0">
                err := fmt.Errorf("invalid token type: %s", tokenType)
                tm.metrics.ObserveTokenGeneration(tokenType, err, time.Since(start))
                return "", err</span>
        }

        <span class="cov9" title="15">claims := &amp;Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(duration)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
                UserID:    userID,
                Roles:     roles,
                TokenType: tokenType,
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(secret))
        tm.metrics.ObserveTokenGeneration(tokenType, err, time.Since(start))
        return tokenString, err</span>
}

// validateToken validates a JWT token
func (tm *TokenManager) validateToken(tokenString string, tokenType TokenType) (*Claims, error) <span class="cov10" title="21">{
        start := time.Now()
        var secret string

        switch tokenType </span>{
        case AccessToken:<span class="cov9" title="20">
                secret = tm.config.Token.AccessTokenSecret</span>
        case RefreshToken:<span class="cov1" title="1">
                secret = tm.config.Token.RefreshTokenSecret</span>
        default:<span class="cov0" title="0">
                err := fmt.Errorf("invalid token type: %s", tokenType)
                tm.metrics.ObserveTokenValidation(tokenType, err, time.Since(start))
                return nil, err</span>
        }

        <span class="cov10" title="21">token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov9" title="17">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov9" title="16">return []byte(secret), nil</span>
        })

        <span class="cov10" title="21">if err != nil </span><span class="cov5" title="5">{
                tm.metrics.ObserveTokenValidation(tokenType, err, time.Since(start))
                return nil, fmt.Errorf("invalid token: %w", err)
        }</span>

        <span class="cov9" title="16">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                err = fmt.Errorf("invalid claims type")
                tm.metrics.ObserveTokenValidation(tokenType, err, time.Since(start))
                return nil, err
        }</span>

        <span class="cov9" title="16">if claims.TokenType != tokenType </span><span class="cov0" title="0">{
                err = fmt.Errorf("token type mismatch: expected %s, got %s", tokenType, claims.TokenType)
                tm.metrics.ObserveTokenValidation(tokenType, err, time.Since(start))
                return nil, err
        }</span>

        <span class="cov9" title="16">tm.metrics.ObserveTokenValidation(tokenType, nil, time.Since(start))
        return claims, nil</span>
}

// GenerateAccessToken generates a new access token
func (tm *TokenManager) GenerateAccessToken(userID string, roles []string) (string, error) <span class="cov8" title="13">{
        return tm.generateToken(userID, roles, AccessToken)
}</span>

// GenerateRefreshToken generates a new refresh token
func (tm *TokenManager) GenerateRefreshToken(userID string, roles []string) (string, error) <span class="cov3" title="2">{
        return tm.generateToken(userID, roles, RefreshToken)
}</span>

// ValidateAccessToken validates an access token
func (tm *TokenManager) ValidateAccessToken(tokenString string) (*Claims, error) <span class="cov9" title="20">{
        return tm.validateToken(tokenString, AccessToken)
}</span>

// ValidateRefreshToken validates a refresh token
func (tm *TokenManager) ValidateRefreshToken(tokenString string) (*Claims, error) <span class="cov1" title="1">{
        return tm.validateToken(tokenString, RefreshToken)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "context"

        "github.com/StackCatalyst/common-lib/pkg/logging"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// LogEvent represents different authentication events that can be logged
type LogEvent string

const (
        // Authentication events
        EventTokenValidation LogEvent = "token_validation"
        EventTokenCreation   LogEvent = "token_creation"
        EventTokenRefresh    LogEvent = "token_refresh"
        EventTokenRevocation LogEvent = "token_revocation"

        // Authorization events
        EventPermissionCheck LogEvent = "permission_check"
        EventRoleAssignment  LogEvent = "role_assignment"
        EventRoleRevocation  LogEvent = "role_revocation"
)

// AuthLogger wraps the common logger with auth-specific functionality
type AuthLogger struct {
        logger *logging.Logger
}

// NewAuthLogger creates a new AuthLogger instance
func NewAuthLogger(logger *logging.Logger) *AuthLogger <span class="cov6" title="3">{
        return &amp;AuthLogger{
                logger: logger.With(zap.String("component", "auth")),
        }
}</span>

// logAuthEvent logs an authentication event with structured data
func (l *AuthLogger) logAuthEvent(ctx context.Context, event LogEvent, level logging.Level, msg string, fields ...zapcore.Field) <span class="cov10" title="6">{
        // Add event type to fields
        fields = append(fields, zap.String("event", string(event)))

        // Get logger with context
        ctxLogger := l.logger.WithContext(ctx)

        // Log at appropriate level
        switch level </span>{
        case logging.Debug:<span class="cov0" title="0">
                ctxLogger.Debug(msg, fields...)</span>
        case logging.Info:<span class="cov6" title="3">
                ctxLogger.Info(msg, fields...)</span>
        case logging.Warn:<span class="cov1" title="1">
                ctxLogger.Warn(msg, fields...)</span>
        case logging.Error:<span class="cov4" title="2">
                ctxLogger.Error(msg, fields...)</span>
        }
}

// LogTokenValidation logs token validation events
func (l *AuthLogger) LogTokenValidation(ctx context.Context, success bool, err error) <span class="cov4" title="2">{
        fields := []zapcore.Field{
                zap.Bool("success", success),
        }
        if err != nil </span><span class="cov1" title="1">{
                fields = append(fields, zap.Error(err))
        }</span>

        <span class="cov4" title="2">level := logging.Info
        msg := "Token validation successful"
        if !success </span><span class="cov1" title="1">{
                level = logging.Error
                msg = "Token validation failed"
        }</span>

        <span class="cov4" title="2">l.logAuthEvent(ctx, EventTokenValidation, level, msg, fields...)</span>
}

// LogTokenCreation logs token creation events
func (l *AuthLogger) LogTokenCreation(ctx context.Context, userID string, success bool, err error) <span class="cov0" title="0">{
        fields := []zapcore.Field{
                zap.String("user_id", userID),
                zap.Bool("success", success),
        }
        if err != nil </span><span class="cov0" title="0">{
                fields = append(fields, zap.Error(err))
        }</span>

        <span class="cov0" title="0">level := logging.Info
        msg := "Token created successfully"
        if !success </span><span class="cov0" title="0">{
                level = logging.Error
                msg = "Token creation failed"
        }</span>

        <span class="cov0" title="0">l.logAuthEvent(ctx, EventTokenCreation, level, msg, fields...)</span>
}

// LogPermissionCheck logs authorization check events
func (l *AuthLogger) LogPermissionCheck(ctx context.Context, userID, role, resource, action string, allowed bool) <span class="cov4" title="2">{
        fields := []zapcore.Field{
                zap.String("user_id", userID),
                zap.String("role", role),
                zap.String("resource", resource),
                zap.String("action", action),
                zap.Bool("allowed", allowed),
        }

        level := logging.Info
        msg := "Permission check"
        if !allowed </span><span class="cov1" title="1">{
                level = logging.Warn
        }</span>

        <span class="cov4" title="2">l.logAuthEvent(ctx, EventPermissionCheck, level, msg, fields...)</span>
}

// LogRoleChange logs role assignment or revocation events
func (l *AuthLogger) LogRoleChange(ctx context.Context, userID, role string, assigned bool, err error) <span class="cov4" title="2">{
        fields := []zapcore.Field{
                zap.String("user_id", userID),
                zap.String("role", role),
                zap.Bool("assigned", assigned),
        }
        if err != nil </span><span class="cov1" title="1">{
                fields = append(fields, zap.Error(err))
        }</span>

        <span class="cov4" title="2">event := EventRoleAssignment
        msg := "Role assigned"
        if !assigned </span><span class="cov1" title="1">{
                event = EventRoleRevocation
                msg = "Role revoked"
        }</span>

        <span class="cov4" title="2">level := logging.Info
        if err != nil </span><span class="cov1" title="1">{
                level = logging.Error
                if assigned </span><span class="cov0" title="0">{
                        msg = "Role assignment failed"
                }</span> else<span class="cov1" title="1"> {
                        msg = "Role revocation failed"
                }</span>
        }

        <span class="cov4" title="2">l.logAuthEvent(ctx, event, level, msg, fields...)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// MetricsReporter handles authentication metrics
type MetricsReporter struct {
        tokenValidations  *prometheus.CounterVec
        tokenGenerations  *prometheus.CounterVec
        permissionChecks  *prometheus.CounterVec
        validationLatency *prometheus.HistogramVec
        generationLatency *prometheus.HistogramVec
        activeTokens      *prometheus.GaugeVec
}

// NewMetricsReporter creates a new authentication metrics reporter
func NewMetricsReporter(reporter *metrics.Reporter) *MetricsReporter <span class="cov7" title="11">{
        return &amp;MetricsReporter{
                tokenValidations: reporter.Counter(
                        "auth_token_validations_total",
                        "Total number of token validations",
                        []string{"type", "status"},
                ),
                tokenGenerations: reporter.Counter(
                        "auth_token_generations_total",
                        "Total number of token generations",
                        []string{"type", "status"},
                ),
                permissionChecks: reporter.Counter(
                        "auth_permission_checks_total",
                        "Total number of permission checks",
                        []string{"resource", "action", "status"},
                ),
                validationLatency: reporter.Histogram(
                        "auth_token_validation_duration_seconds",
                        "Token validation duration in seconds",
                        []string{"type"},
                        []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1},
                ),
                generationLatency: reporter.Histogram(
                        "auth_token_generation_duration_seconds",
                        "Token generation duration in seconds",
                        []string{"type"},
                        []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1},
                ),
                activeTokens: reporter.Gauge(
                        "auth_active_tokens",
                        "Number of active tokens",
                        []string{"type"},
                ),
        }
}</span>

// ObserveTokenValidation records a token validation attempt
func (m *MetricsReporter) ObserveTokenValidation(tokenType TokenType, err error, duration time.Duration) <span class="cov10" title="23">{
        status := "success"
        if err != nil </span><span class="cov6" title="6">{
                status = "failure"
        }</span>
        <span class="cov10" title="23">m.tokenValidations.WithLabelValues(string(tokenType), status).Inc()
        m.validationLatency.WithLabelValues(string(tokenType)).Observe(duration.Seconds())</span>
}

// ObserveTokenGeneration records a token generation attempt
func (m *MetricsReporter) ObserveTokenGeneration(tokenType TokenType, err error, duration time.Duration) <span class="cov9" title="17">{
        status := "success"
        if err != nil </span><span class="cov1" title="1">{
                status = "failure"
        }</span>
        <span class="cov9" title="17">m.tokenGenerations.WithLabelValues(string(tokenType), status).Inc()
        m.generationLatency.WithLabelValues(string(tokenType)).Observe(duration.Seconds())</span>
}

// ObservePermissionCheck records a permission check attempt
func (m *MetricsReporter) ObservePermissionCheck(resource Resource, action Action, err error) <span class="cov2" title="2">{
        status := "allowed"
        if err != nil </span><span class="cov1" title="1">{
                status = "denied"
        }</span>
        <span class="cov2" title="2">m.permissionChecks.WithLabelValues(string(resource), string(action), status).Inc()</span>
}

// SetActiveTokens sets the number of active tokens
func (m *MetricsReporter) SetActiveTokens(tokenType TokenType, count int) <span class="cov2" title="2">{
        m.activeTokens.WithLabelValues(string(tokenType)).Set(float64(count))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "context"
        "net/http"
        "strings"

        "github.com/StackCatalyst/common-lib/pkg/errors"
        "github.com/gin-gonic/gin"
)

type contextKey string

const (
        // UserIDKey is the context key for user ID
        UserIDKey contextKey = "user_id"
        // UserRolesKey is the context key for user roles
        UserRolesKey contextKey = "user_roles"
        // AuthHeaderKey is the authorization header key
        AuthHeaderKey = "Authorization"
        // BearerSchema is the bearer token schema
        BearerSchema = "Bearer"
)

// AuthMiddleware creates a Gin middleware for JWT authentication
func AuthMiddleware(tm *TokenManager) gin.HandlerFunc <span class="cov8" title="10">{
        return func(c *gin.Context) </span><span class="cov8" title="11">{
                // Extract token from header
                authHeader := c.GetHeader(AuthHeaderKey)
                if authHeader == "" </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "error": "no authorization header",
                        })
                        return
                }</span>

                // Check bearer schema
                <span class="cov8" title="10">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != BearerSchema </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "error": "invalid authorization header format",
                        })
                        return
                }</span>

                // Validate token
                <span class="cov7" title="9">claims, err := tm.ValidateAccessToken(parts[1])
                if err != nil </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "error": err.Error(),
                        })
                        return
                }</span>

                // Set claims in context
                <span class="cov7" title="8">ctx := context.WithValue(c.Request.Context(), UserIDKey, claims.UserID)
                ctx = context.WithValue(ctx, UserRolesKey, claims.Roles)
                c.Request = c.Request.WithContext(ctx)

                c.Next()</span>
        }
}

// RequireRole creates a Gin middleware for role-based authorization
func RequireRole(rbac *RBAC, role Role) gin.HandlerFunc <span class="cov6" title="5">{
        return func(c *gin.Context) </span><span class="cov6" title="5">{
                userRoles, exists := c.Request.Context().Value(UserRolesKey).([]string)
                if !exists </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "error": "user roles not found in context",
                        })
                        return
                }</span>

                <span class="cov6" title="5">if !rbac.HasRole(userRoles, role) </span><span class="cov3" title="2">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                "error": "insufficient permissions",
                        })
                        return
                }</span>

                <span class="cov4" title="3">c.Next()</span>
        }
}

// RequirePermission creates a Gin middleware for permission-based authorization
func RequirePermission(rbac *RBAC, resource Resource, action Action) gin.HandlerFunc <span class="cov6" title="5">{
        return func(c *gin.Context) </span><span class="cov5" title="4">{
                userRoles, exists := c.Request.Context().Value(UserRolesKey).([]string)
                if !exists </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                                "error": "user roles not found in context",
                        })
                        return
                }</span>

                <span class="cov5" title="4">if !rbac.IsAllowed(userRoles, resource, action) </span><span class="cov1" title="1">{
                        c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                                "error": "insufficient permissions",
                        })
                        return
                }</span>

                <span class="cov4" title="3">c.Next()</span>
        }
}

// GetUserID retrieves the user ID from the context
func GetUserID(ctx context.Context) (string, error) <span class="cov8" title="10">{
        userID, ok := ctx.Value(UserIDKey).(string)
        if !ok </span><span class="cov1" title="1">{
                return "", errors.New(errors.ErrUnauthorized, "user ID not found in context")
        }</span>
        <span class="cov7" title="9">return userID, nil</span>
}

// GetUserRoles retrieves the user roles from the context
func GetUserRoles(ctx context.Context) ([]string, error) <span class="cov10" title="18">{
        roles, ok := ctx.Value(UserRolesKey).([]string)
        if !ok </span><span class="cov4" title="3">{
                return nil, errors.New(errors.ErrUnauthorized, "user roles not found in context")
        }</span>
        <span class="cov9" title="15">return roles, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package auth

import (
        "strings"

        "github.com/StackCatalyst/common-lib/pkg/errors"
)

// Permission represents an action on a resource
type Permission string

// Resource represents a protected resource
type Resource string

// Role represents a set of permissions
type Role string

// Action represents the type of operation
type Action string

const (
        // Common actions
        ActionCreate Action = "create"
        ActionRead   Action = "read"
        ActionUpdate Action = "update"
        ActionDelete Action = "delete"
        ActionList   Action = "list"
        ActionWrite  Action = "write"

        // Special actions
        ActionAll Action = "*"
)

// BuildPermission creates a permission string from resource and action
func BuildPermission(resource Resource, action Action) Permission <span class="cov10" title="38">{
        return Permission(string(resource) + ":" + string(action))
}</span>

// RBAC manages role-based access control
type RBAC struct {
        // rolePermissions maps roles to their permissions
        rolePermissions map[Role]map[Permission]bool
        // roleHierarchy maps roles to their parent roles
        roleHierarchy map[Role][]Role
}

// NewRBAC creates a new RBAC manager
func NewRBAC() *RBAC <span class="cov7" title="12">{
        return &amp;RBAC{
                rolePermissions: make(map[Role]map[Permission]bool),
                roleHierarchy:   make(map[Role][]Role),
        }
}</span>

// AddRole adds a new role with optional parent roles
func (r *RBAC) AddRole(role Role, parents ...Role) error <span class="cov8" title="22">{
        if _, exists := r.rolePermissions[role]; exists </span><span class="cov1" title="1">{
                return errors.New(errors.ErrValidation, "role already exists")
        }</span>

        <span class="cov8" title="21">r.rolePermissions[role] = make(map[Permission]bool)
        if len(parents) &gt; 0 </span><span class="cov3" title="3">{
                r.roleHierarchy[role] = parents
        }</span>

        <span class="cov8" title="21">return nil</span>
}

// AddPermission adds permissions to a role
func (r *RBAC) AddPermission(role Role, permissions ...Permission) error <span class="cov7" title="14">{
        perms, exists := r.rolePermissions[role]
        if !exists </span><span class="cov1" title="1">{
                return errors.New(errors.ErrNotFound, "role not found")
        }</span>

        <span class="cov7" title="13">for _, perm := range permissions </span><span class="cov7" title="15">{
                perms[perm] = true
        }</span>

        <span class="cov7" title="13">return nil</span>
}

// RemovePermission removes permissions from a role
func (r *RBAC) RemovePermission(role Role, permissions ...Permission) error <span class="cov1" title="1">{
        perms, exists := r.rolePermissions[role]
        if !exists </span><span class="cov0" title="0">{
                return errors.New(errors.ErrNotFound, "role not found")
        }</span>

        <span class="cov1" title="1">for _, perm := range permissions </span><span class="cov1" title="1">{
                delete(perms, perm)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// HasPermission checks if a role has a specific permission
func (r *RBAC) HasPermission(role Role, permission Permission) bool <span class="cov9" title="33">{
        // Check direct permissions
        if r.hasDirectPermission(role, permission) </span><span class="cov8" title="17">{
                return true
        }</span>

        // Check parent roles recursively
        <span class="cov7" title="16">return r.hasParentPermission(role, permission)</span>
}

// HasRole checks if a user has a specific role
func (r *RBAC) HasRole(userRoles []string, role Role) bool <span class="cov6" title="8">{
        for _, ur := range userRoles </span><span class="cov6" title="10">{
                if Role(ur) == role </span><span class="cov4" title="5">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

// IsAllowed checks if a user has permission to perform an action
func (r *RBAC) IsAllowed(userRoles []string, resource Resource, action Action) bool <span class="cov8" title="18">{
        permission := BuildPermission(resource, action)

        // Check each role the user has
        for _, roleStr := range userRoles </span><span class="cov8" title="19">{
                role := Role(roleStr)
                if r.HasPermission(role, permission) || r.HasPermission(role, BuildPermission(resource, ActionAll)) </span><span class="cov7" title="13">{
                        return true
                }</span>
        }

        <span class="cov4" title="5">return false</span>
}

func (r *RBAC) hasDirectPermission(role Role, permission Permission) bool <span class="cov9" title="35">{
        perms, exists := r.rolePermissions[role]
        if !exists </span><span class="cov4" title="4">{
                return false
        }</span>

        // Check for exact permission match
        <span class="cov9" title="31">if perms[permission] </span><span class="cov7" title="14">{
                return true
        }</span>

        // Check for wildcard permissions
        <span class="cov8" title="17">parts := strings.Split(string(permission), ":")
        if len(parts) == 2 </span><span class="cov8" title="17">{
                wildcardPerm := Permission(parts[0] + ":*")
                return perms[wildcardPerm]
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (r *RBAC) hasParentPermission(role Role, permission Permission) bool <span class="cov7" title="16">{
        parents, exists := r.roleHierarchy[role]
        if !exists </span><span class="cov7" title="14">{
                return false
        }</span>

        <span class="cov2" title="2">for _, parent := range parents </span><span class="cov2" title="2">{
                if r.hasDirectPermission(parent, permission) </span><span class="cov2" title="2">{
                        return true
                }</span>
                <span class="cov0" title="0">if r.hasParentPermission(parent, permission) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// Config holds the cache configuration
type Config struct {
        // Enabled indicates if caching is enabled
        Enabled bool `json:"enabled" yaml:"enabled"`
        // TTL is the default time-to-live for cache entries
        TTL time.Duration `json:"ttl" yaml:"ttl"`
        // MaxSize is the maximum cache size in bytes
        MaxSize int64 `json:"max_size" yaml:"max_size"`
        // PurgeInterval is how often to check for expired entries
        PurgeInterval time.Duration `json:"purge_interval" yaml:"purge_interval"`
}

// DefaultConfig returns the default cache configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Enabled:       true,
                TTL:           time.Hour,
                MaxSize:       1024 * 1024 * 1024, // 1GB
                PurgeInterval: time.Minute * 5,
        }
}</span>

// entry represents a cache entry
type entry struct {
        value     []byte
        size      int64
        expiresAt time.Time
}

// Cache represents an in-memory cache with TTL and size limits
type Cache struct {
        config     *Config
        mu         sync.RWMutex
        data       map[string]*entry
        totalBytes int64

        // Metrics
        hits        *prometheus.CounterVec
        misses      *prometheus.CounterVec
        sizeMetric  *prometheus.GaugeVec
        itemsMetric *prometheus.GaugeVec
}

// New creates a new cache instance
func New(config *Config, metricsReporter *metrics.Reporter) *Cache <span class="cov4" title="3">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        <span class="cov4" title="3">c := &amp;Cache{
                config: config,
                data:   make(map[string]*entry),
                hits: metricsReporter.Counter("cache_hits_total",
                        "Total number of cache hits",
                        []string{"cache"}),
                misses: metricsReporter.Counter("cache_misses_total",
                        "Total number of cache misses",
                        []string{"cache"}),
                sizeMetric: metricsReporter.Gauge("cache_size_bytes",
                        "Current size of cache in bytes",
                        []string{"cache"}),
                itemsMetric: metricsReporter.Gauge("cache_items_total",
                        "Total number of items in cache",
                        []string{"cache"}),
        }

        // Start background cleanup if enabled
        if config.Enabled &amp;&amp; config.PurgeInterval &gt; 0 </span><span class="cov3" title="2">{
                go c.startCleanup(context.Background())
        }</span>

        <span class="cov4" title="3">return c</span>
}

// Set stores a value in the cache
func (c *Cache) Set(ctx context.Context, key string, value interface{}) error <span class="cov6" title="7">{
        if !c.config.Enabled </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Convert value to bytes
        <span class="cov6" title="6">data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal value: %w", err)
        }</span>

        <span class="cov6" title="6">size := int64(len(data))
        if size &gt; c.config.MaxSize </span><span class="cov0" title="0">{
                return fmt.Errorf("value size %d exceeds maximum cache size %d", size, c.config.MaxSize)
        }</span>

        <span class="cov6" title="6">c.mu.Lock()
        defer c.mu.Unlock()

        // Check if we need to make room
        if c.totalBytes+size &gt; c.config.MaxSize </span><span class="cov1" title="1">{
                c.evict(size)
        }</span>

        // Store the entry
        <span class="cov6" title="6">c.data[key] = &amp;entry{
                value:     data,
                size:      size,
                expiresAt: time.Now().Add(c.config.TTL),
        }

        c.totalBytes += size
        c.itemsMetric.WithLabelValues("memory").Inc()
        c.sizeMetric.WithLabelValues("memory").Set(float64(c.totalBytes))

        return nil</span>
}

// Get retrieves a value from the cache
func (c *Cache) Get(ctx context.Context, key string, value interface{}) bool <span class="cov7" title="9">{
        if !c.config.Enabled </span><span class="cov1" title="1">{
                c.misses.WithLabelValues("memory").Inc()
                return false
        }</span>

        <span class="cov7" title="8">c.mu.RLock()
        entry, exists := c.data[key]
        if !exists || time.Now().After(entry.expiresAt) </span><span class="cov6" title="6">{
                c.mu.RUnlock()
                c.misses.WithLabelValues("memory").Inc()
                return false
        }</span>
        <span class="cov3" title="2">data := entry.value
        c.mu.RUnlock()

        if err := json.Unmarshal(data, value); err != nil </span><span class="cov0" title="0">{
                c.misses.WithLabelValues("memory").Inc()
                return false
        }</span>

        <span class="cov3" title="2">c.hits.WithLabelValues("memory").Inc()
        return true</span>
}

// Delete removes a value from the cache
func (c *Cache) Delete(ctx context.Context, key string) <span class="cov1" title="1">{
        if !c.config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">c.mu.Lock()
        if entry, exists := c.data[key]; exists </span><span class="cov1" title="1">{
                c.totalBytes -= entry.size
                delete(c.data, key)
                c.itemsMetric.WithLabelValues("memory").Dec()
                c.sizeMetric.WithLabelValues("memory").Set(float64(c.totalBytes))
        }</span>
        <span class="cov1" title="1">c.mu.Unlock()</span>
}

// Clear removes all values from the cache
func (c *Cache) Clear(ctx context.Context) <span class="cov1" title="1">{
        if !c.config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">c.mu.Lock()
        c.data = make(map[string]*entry)
        c.totalBytes = 0
        c.itemsMetric.WithLabelValues("memory").Set(0)
        c.sizeMetric.WithLabelValues("memory").Set(0)
        c.mu.Unlock()</span>
}

// evict removes entries to make room for the requested size
func (c *Cache) evict(needed int64) <span class="cov1" title="1">{
        // Simple LRU-like eviction: remove oldest entries first
        for key, entry := range c.data </span><span class="cov1" title="1">{
                if c.totalBytes+needed &lt;= c.config.MaxSize </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov1" title="1">c.totalBytes -= entry.size
                delete(c.data, key)
                c.itemsMetric.WithLabelValues("memory").Dec()</span>
        }
}

// startCleanup runs periodic cleanup of expired entries
func (c *Cache) startCleanup(ctx context.Context) <span class="cov3" title="2">{
        ticker := time.NewTicker(c.config.PurgeInterval)
        defer ticker.Stop()

        for </span><span class="cov10" title="22">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov9" title="20">
                        c.cleanup()</span>
                }
        }
}

// cleanup removes expired entries
func (c *Cache) cleanup() <span class="cov9" title="20">{
        now := time.Now()
        c.mu.Lock()
        for key, entry := range c.data </span><span class="cov7" title="10">{
                if now.After(entry.expiresAt) </span><span class="cov1" title="1">{
                        c.totalBytes -= entry.size
                        delete(c.data, key)
                        c.itemsMetric.WithLabelValues("memory").Dec()
                }</span>
        }
        <span class="cov9" title="20">c.sizeMetric.WithLabelValues("memory").Set(float64(c.totalBytes))
        c.mu.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "strings"
        "time"

        "github.com/fsnotify/fsnotify"
        "github.com/spf13/viper"
)

// Manager handles configuration management
type Manager struct {
        v *viper.Viper
}

// Options configures the behavior of the config manager
type Options struct {
        // ConfigName is the name of the config file without extension
        ConfigName string
        // ConfigType is the type of the config file (yaml, json, etc.)
        ConfigType string
        // ConfigPaths are the paths to search for config files
        ConfigPaths []string
        // EnvPrefix is the prefix for environment variables
        EnvPrefix string
        // AutomaticEnv enables automatic environment variable binding
        AutomaticEnv bool
}

// DefaultOptions returns the default configuration options
func DefaultOptions() Options <span class="cov6" title="6">{
        return Options{
                ConfigName:   "config",
                ConfigType:   "yaml",
                ConfigPaths:  []string{".", "./config", "/etc/terraorbit"},
                EnvPrefix:    "TERRAORBIT",
                AutomaticEnv: true,
        }
}</span>

// New creates a new configuration manager
func New(opts Options) (*Manager, error) <span class="cov7" title="8">{
        v := viper.New()

        // Set config name and type
        v.SetConfigName(opts.ConfigName)
        v.SetConfigType(opts.ConfigType)

        // Add config paths
        for _, path := range opts.ConfigPaths </span><span class="cov8" title="12">{
                v.AddConfigPath(path)
        }</span>

        // Configure environment variables
        <span class="cov7" title="8">if opts.AutomaticEnv </span><span class="cov7" title="8">{
                v.AutomaticEnv()
                v.SetEnvPrefix(opts.EnvPrefix)
                v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        }</span>

        // Read config file
        <span class="cov7" title="8">if err := v.ReadInConfig(); err != nil </span><span class="cov3" title="2">{
                // It's okay if we can't find a config file
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading config file: %w", err)
                }</span>
        }

        <span class="cov7" title="8">return &amp;Manager{v: v}, nil</span>
}

// Get retrieves a value from the configuration
func (m *Manager) Get(key string) interface{} <span class="cov0" title="0">{
        return m.v.Get(key)
}</span>

// GetString retrieves a string value from the configuration
func (m *Manager) GetString(key string) string <span class="cov10" title="20">{
        return m.v.GetString(key)
}</span>

// GetInt retrieves an integer value from the configuration
func (m *Manager) GetInt(key string) int <span class="cov7" title="10">{
        return m.v.GetInt(key)
}</span>

// GetBool retrieves a boolean value from the configuration
func (m *Manager) GetBool(key string) bool <span class="cov5" title="4">{
        return m.v.GetBool(key)
}</span>

// GetDuration retrieves a duration value from the configuration
func (m *Manager) GetDuration(key string) time.Duration <span class="cov7" title="9">{
        return m.v.GetDuration(key)
}</span>

// GetStringSlice retrieves a string slice from the configuration
func (m *Manager) GetStringSlice(key string) []string <span class="cov1" title="1">{
        return m.v.GetStringSlice(key)
}</span>

// GetStringMap retrieves a string map from the configuration
func (m *Manager) GetStringMap(key string) map[string]interface{} <span class="cov5" title="5">{
        return m.v.GetStringMap(key)
}</span>

// Set sets a value in the configuration
func (m *Manager) Set(key string, value interface{}) <span class="cov9" title="17">{
        m.v.Set(key, value)
}</span>

// UnmarshalKey takes a key and unmarshals it into a struct
func (m *Manager) UnmarshalKey(key string, rawVal interface{}) error <span class="cov0" title="0">{
        return m.v.UnmarshalKey(key, rawVal)
}</span>

// Unmarshal unmarshals the config into a struct
func (m *Manager) Unmarshal(rawVal interface{}) error <span class="cov1" title="1">{
        return m.v.Unmarshal(rawVal)
}</span>

// WatchConfig watches for configuration changes
func (m *Manager) WatchConfig(onChange func()) <span class="cov0" title="0">{
        m.v.OnConfigChange(func(_ fsnotify.Event) </span><span class="cov0" title="0">{
                if onChange != nil </span><span class="cov0" title="0">{
                        onChange()
                }</span>
        })
        <span class="cov0" title="0">m.v.WatchConfig()</span>
}

// WriteConfig writes the current configuration to file
func (m *Manager) WriteConfig() error <span class="cov0" title="0">{
        return m.v.WriteConfig()
}</span>

// WriteConfigAs writes the current configuration to a specific file
func (m *Manager) WriteConfigAs(filename string) error <span class="cov0" title="0">{
        return m.v.WriteConfigAs(filename)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

// Config holds the database configuration
type Config struct {
        // Host is the database server hostname
        Host string `json:"host" yaml:"host"`
        // Port is the database server port
        Port int `json:"port" yaml:"port"`
        // Database is the name of the database to connect to
        Database string `json:"database" yaml:"database"`
        // User is the database user
        User string `json:"user" yaml:"user"`
        // Password is the database password
        Password string `json:"password" yaml:"password"`
        // SSLMode is the SSL mode to use for the connection
        SSLMode string `json:"ssl_mode" yaml:"ssl_mode"`
        // MaxConns is the maximum number of connections in the pool
        MaxConns int32 `json:"max_conns" yaml:"max_conns"`
        // MinConns is the minimum number of connections in the pool
        MinConns int32 `json:"min_conns" yaml:"min_conns"`
        // MaxConnLifetime is the maximum lifetime of a connection
        MaxConnLifetime time.Duration `json:"max_conn_lifetime" yaml:"max_conn_lifetime"`
        // MaxConnIdleTime is the maximum idle time of a connection
        MaxConnIdleTime time.Duration `json:"max_conn_idle_time" yaml:"max_conn_idle_time"`
}

// DefaultConfig returns the default database configuration
func DefaultConfig() Config <span class="cov1" title="1">{
        return Config{
                Host:            "localhost",
                Port:            5432,
                SSLMode:         "disable",
                MaxConns:        4,
                MinConns:        0,
                MaxConnLifetime: time.Hour,
                MaxConnIdleTime: 30 * time.Minute,
        }
}</span>

// Validate validates the database configuration
func (c *Config) Validate() error <span class="cov10" title="9">{
        if c.Host == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("host must be provided")
        }</span>
        <span class="cov9" title="8">if c.Port &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("port must be greater than 0")
        }</span>
        <span class="cov8" title="7">if c.Database == "" </span><span class="cov3" title="2">{
                return fmt.Errorf("database must be provided")
        }</span>
        <span class="cov7" title="5">if c.User == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("user must be provided")
        }</span>
        <span class="cov6" title="4">if c.Password == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("password must be provided")
        }</span>
        <span class="cov5" title="3">if c.MaxConns &lt; c.MinConns </span><span class="cov1" title="1">{
                return fmt.Errorf("max_conns must be greater than or equal to min_conns")
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// Client is a database client that provides connection management and metrics
type Client struct {
        pool    *pgxpool.Pool
        metrics *MetricsReporter
}

// New creates a new database client
func New(config Config, metricsReporter *metrics.Reporter) (*Client, error) <span class="cov3" title="2">{
        if err := config.Validate(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov1" title="1">connString := fmt.Sprintf(
                "host=%s port=%d dbname=%s user=%s password=%s sslmode=%s",
                config.Host,
                config.Port,
                config.Database,
                config.User,
                config.Password,
                config.SSLMode,
        )

        poolConfig, err := pgxpool.ParseConfig(connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing connection string: %w", err)
        }</span>

        <span class="cov1" title="1">poolConfig.MaxConns = config.MaxConns
        poolConfig.MinConns = config.MinConns
        poolConfig.MaxConnLifetime = config.MaxConnLifetime
        poolConfig.MaxConnIdleTime = config.MaxConnIdleTime

        pool, err := pgxpool.NewWithConfig(context.Background(), poolConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating connection pool: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;Client{
                pool:    pool,
                metrics: NewMetricsReporter(metricsReporter),
        }, nil</span>
}

// Close closes the database client and its connection pool
func (c *Client) Close() <span class="cov1" title="1">{
        if c.pool != nil </span><span class="cov1" title="1">{
                c.pool.Close()
        }</span>
}

// Ping verifies a connection to the database is still alive
func (c *Client) Ping(ctx context.Context) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.pool.Ping(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.metrics.ObserveConnectionError("ping")
        }</span>
        <span class="cov0" title="0">c.metrics.ObserveQuery("ping", err, time.Since(start))
        return err</span>
}

// Begin starts a new transaction
func (c *Client) Begin(ctx context.Context) (pgx.Tx, error) <span class="cov0" title="0">{
        start := time.Now()
        tx, err := c.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.metrics.ObserveConnectionError("begin_transaction")
        }</span>
        <span class="cov0" title="0">c.metrics.ObserveQuery("begin_transaction", err, time.Since(start))
        return tx, err</span>
}

// BeginTx starts a new transaction with the specified options
func (c *Client) BeginTx(ctx context.Context, txOptions pgx.TxOptions) (pgx.Tx, error) <span class="cov0" title="0">{
        start := time.Now()
        tx, err := c.pool.BeginTx(ctx, txOptions)
        if err != nil </span><span class="cov0" title="0">{
                c.metrics.ObserveConnectionError("begin_transaction")
        }</span>
        <span class="cov0" title="0">c.metrics.ObserveQuery("begin_transaction", err, time.Since(start))
        return tx, err</span>
}

// Query executes a query that returns rows
func (c *Client) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) <span class="cov0" title="0">{
        start := time.Now()
        rows, err := c.pool.Query(ctx, sql, args...)
        c.metrics.ObserveQuery("query", err, time.Since(start))
        return rows, err
}</span>

// QueryRow executes a query that is expected to return at most one row
func (c *Client) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row <span class="cov0" title="0">{
        start := time.Now()
        row := c.pool.QueryRow(ctx, sql, args...)
        c.metrics.ObserveQuery("query_row", nil, time.Since(start))
        return row
}</span>

// Exec executes a query that doesn't return rows
func (c *Client) Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error) <span class="cov0" title="0">{
        start := time.Now()
        tag, err := c.pool.Exec(ctx, sql, args...)
        c.metrics.ObserveQuery("exec", err, time.Since(start))
        return tag, err
}</span>

// UpdatePoolStats updates the pool statistics metrics
func (c *Client) UpdatePoolStats() <span class="cov0" title="0">{
        stats := c.pool.Stat()
        c.metrics.SetPoolStats(
                int64(stats.TotalConns()),
                int64(stats.IdleConns()),
                int64(stats.AcquiredConns()),
        )
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// MetricsReporter handles database metrics reporting
type MetricsReporter struct {
        queryExecutions  *prometheus.CounterVec
        queryLatency     *prometheus.HistogramVec
        connectionErrors *prometheus.CounterVec
        poolStats        *prometheus.GaugeVec
}

// NewMetricsReporter creates a new database metrics reporter
func NewMetricsReporter(reporter *metrics.Reporter) *MetricsReporter <span class="cov8" title="3">{
        return &amp;MetricsReporter{
                queryExecutions: reporter.Counter(
                        "database_query_executions_total",
                        "Total number of database query executions",
                        []string{"type", "status"},
                ),
                queryLatency: reporter.Histogram(
                        "database_query_duration_seconds",
                        "Database query duration in seconds",
                        []string{"type"},
                        []float64{0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1},
                ),
                connectionErrors: reporter.Counter(
                        "database_connection_errors_total",
                        "Total number of database connection errors",
                        []string{"type"},
                ),
                poolStats: reporter.Gauge(
                        "database_pool_stats",
                        "Database connection pool statistics",
                        []string{"type"},
                ),
        }
}</span>

// ObserveQuery records a query execution
func (m *MetricsReporter) ObserveQuery(queryType string, err error, duration time.Duration) <span class="cov10" title="4">{
        status := "success"
        if err != nil </span><span class="cov5" title="2">{
                status = "failure"
        }</span>
        <span class="cov10" title="4">m.queryExecutions.WithLabelValues(queryType, status).Inc()
        m.queryLatency.WithLabelValues(queryType).Observe(duration.Seconds())</span>
}

// ObserveConnectionError records a connection error
func (m *MetricsReporter) ObserveConnectionError(errorType string) <span class="cov8" title="3">{
        m.connectionErrors.WithLabelValues(errorType).Inc()
}</span>

// SetPoolStats sets the current pool statistics
func (m *MetricsReporter) SetPoolStats(totalConns, idleConns, inUseConns int64) <span class="cov5" title="2">{
        m.poolStats.WithLabelValues("total").Set(float64(totalConns))
        m.poolStats.WithLabelValues("idle").Set(float64(idleConns))
        m.poolStats.WithLabelValues("in_use").Set(float64(inUseConns))
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package errors

import (
        "context"
        "fmt"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/pkg/errors"
)

// RetryableError represents an error that can be retried
type RetryableError struct {
        *AppError
        MaxRetries  int
        RetryAfter  time.Duration
        RetryCount  int
        LastAttempt time.Time
}

// NewRetryable creates a new RetryableError
func NewRetryable(err *AppError, maxRetries int, retryAfter time.Duration) *RetryableError <span class="cov1" title="1">{
        return &amp;RetryableError{
                AppError:    err,
                MaxRetries:  maxRetries,
                RetryAfter:  retryAfter,
                RetryCount:  0,
                LastAttempt: time.Now().Add(-2 * retryAfter),
        }
}</span>

// CanRetry checks if the error can be retried
func (e *RetryableError) CanRetry() bool <span class="cov10" title="5">{
        return e.RetryCount &lt; e.MaxRetries &amp;&amp; time.Since(e.LastAttempt) &gt;= e.RetryAfter
}</span>

// Attempt increments the retry count and updates the last attempt time
func (e *RetryableError) Attempt() <span class="cov7" title="3">{
        e.RetryCount++
        e.LastAttempt = time.Now()
}</span>

// ErrorGroup represents a collection of errors
type ErrorGroup struct {
        mu     sync.Mutex
        errors []error
}

// NewErrorGroup creates a new ErrorGroup
func NewErrorGroup() *ErrorGroup <span class="cov1" title="1">{
        return &amp;ErrorGroup{
                errors: make([]error, 0),
        }
}</span>

// Add adds an error to the group
func (g *ErrorGroup) Add(err error) <span class="cov7" title="3">{
        if err == nil </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="2">g.mu.Lock()
        g.errors = append(g.errors, err)
        g.mu.Unlock()</span>
}

// HasErrors checks if the group contains any errors
func (g *ErrorGroup) HasErrors() bool <span class="cov8" title="4">{
        return len(g.errors) &gt; 0
}</span>

// Error implements the error interface
func (g *ErrorGroup) Error() string <span class="cov4" title="2">{
        if !g.HasErrors() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov4" title="2">if len(g.errors) == 1 </span><span class="cov0" title="0">{
                return g.errors[0].Error()
        }</span>

        <span class="cov4" title="2">msg := fmt.Sprintf("%d errors occurred:\n", len(g.errors))
        for i, err := range g.errors </span><span class="cov8" title="4">{
                msg += fmt.Sprintf("  %d) %s\n", i+1, err.Error())
        }</span>
        <span class="cov4" title="2">return msg</span>
}

// ErrorContext adds context to errors
type ErrorContext struct {
        context.Context
        err error
}

// NewErrorContext creates a new ErrorContext
func NewErrorContext(ctx context.Context, err error) *ErrorContext <span class="cov1" title="1">{
        return &amp;ErrorContext{
                Context: ctx,
                err:     err,
        }
}</span>

// Error implements the error interface
func (c *ErrorContext) Error() string <span class="cov0" title="0">{
        return c.err.Error()
}</span>

// GetContext returns the context
func (c *ErrorContext) GetContext() context.Context <span class="cov1" title="1">{
        return c.Context
}</span>

// WithContext wraps an error with context
func WithContext(ctx context.Context, err error) error <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">return NewErrorContext(ctx, err)</span>
}

// GetErrorContext extracts context from an error
func GetErrorContext(err error) (context.Context, bool) <span class="cov4" title="2">{
        var errCtx *ErrorContext
        if errors.As(err, &amp;errCtx) </span><span class="cov1" title="1">{
                return errCtx.GetContext(), true
        }</span>
        <span class="cov1" title="1">return nil, false</span>
}

// StackFrame represents a single stack frame
type StackFrame struct {
        File     string
        Line     int
        Function string
}

// String returns a string representation of the stack frame
func (f StackFrame) String() string <span class="cov1" title="1">{
        return fmt.Sprintf("%s:%d %s", f.File, f.Line, f.Function)
}</span>

// ErrorStack represents an error with a stack trace
type ErrorStack struct {
        *AppError
        stack []StackFrame
}

// NewErrorStack creates a new ErrorStack
func NewErrorStack(err *AppError) *ErrorStack <span class="cov1" title="1">{
        return &amp;ErrorStack{
                AppError: err,
                stack:    callers(),
        }
}</span>

// Stack returns the error's stack trace
func (e *ErrorStack) Stack() []StackFrame <span class="cov1" title="1">{
        return e.stack
}</span>

// callers returns the current stack trace
func callers() []StackFrame <span class="cov1" title="1">{
        const depth = 32
        var pcs [depth]uintptr
        n := runtime.Callers(3, pcs[:])
        frames := runtime.CallersFrames(pcs[:n])

        stack := make([]StackFrame, 0, n)
        for </span><span class="cov7" title="3">{
                frame, more := frames.Next()
                if !more </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov4" title="2">if strings.Contains(frame.Function, "runtime.") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="2">stack = append(stack, StackFrame{
                        File:     frame.File,
                        Line:     frame.Line,
                        Function: frame.Function,
                })</span>
        }
        <span class="cov1" title="1">return stack</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package errors

import (
        "fmt"

        "github.com/pkg/errors"
)

// ErrorCode represents a unique error code for different types of errors
type ErrorCode string

// Standard error codes
const (
        ErrNotFound     ErrorCode = "NOT_FOUND"
        ErrUnauthorized ErrorCode = "UNAUTHORIZED"
        ErrValidation   ErrorCode = "VALIDATION"
        ErrInternal     ErrorCode = "INTERNAL"
)

// AppError represents an application-specific error
type AppError struct {
        Code    ErrorCode
        Message string
        Err     error
}

// Error implements the error interface
func (e *AppError) Error() string <span class="cov9" title="29">{
        if e.Err != nil </span><span class="cov5" title="5">{
                return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
        }</span>
        <span class="cov8" title="24">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

// Unwrap returns the underlying error
func (e *AppError) Unwrap() error <span class="cov4" title="4">{
        return e.Err
}</span>

// New creates a new AppError
func New(code ErrorCode, message string) *AppError <span class="cov10" title="37">{
        return &amp;AppError{
                Code:    code,
                Message: message,
        }
}</span>

// Wrap wraps an existing error with additional context
func Wrap(err error, code ErrorCode, message string) *AppError <span class="cov5" title="5">{
        return &amp;AppError{
                Code:    code,
                Message: message,
                Err:     err,
        }
}</span>

// Is reports whether the error chain contains a specific error code
func Is(err error, code ErrorCode) bool <span class="cov3" title="3">{
        var appErr *AppError
        if errors.As(err, &amp;appErr) </span><span class="cov3" title="3">{
                return appErr.Code == code
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package grpc

import (
        "context"
        "fmt"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/keepalive"
)

// Config holds the gRPC client configuration
type Config struct {
        // Target is the server address to connect to
        Target string `json:"target" yaml:"target"`
        // Timeout is the maximum time to wait for a request to complete
        Timeout time.Duration `json:"timeout" yaml:"timeout"`
        // DialTimeout is the maximum time to wait for connection establishment
        DialTimeout time.Duration `json:"dial_timeout" yaml:"dial_timeout"`
        // KeepAlive is the keepalive configuration
        KeepAlive KeepAliveConfig `json:"keep_alive" yaml:"keep_alive"`
        // MaxRetries is the maximum number of retries for a request
        MaxRetries int `json:"max_retries" yaml:"max_retries"`
        // RetryWaitMin is the minimum time to wait between retries
        RetryWaitMin time.Duration `json:"retry_wait_min" yaml:"retry_wait_min"`
        // RetryWaitMax is the maximum time to wait between retries
        RetryWaitMax time.Duration `json:"retry_wait_max" yaml:"retry_wait_max"`
}

// KeepAliveConfig holds the keepalive configuration
type KeepAliveConfig struct {
        // Time is the duration after which if there are no client requests,
        // a keepalive ping will be sent
        Time time.Duration `json:"time" yaml:"time"`
        // Timeout is the duration the client waits for a response to a keepalive ping
        Timeout time.Duration `json:"timeout" yaml:"timeout"`
}

// DefaultConfig returns the default gRPC client configuration
func DefaultConfig() Config <span class="cov1" title="1">{
        return Config{
                Timeout:     30 * time.Second,
                DialTimeout: 10 * time.Second,
                KeepAlive: KeepAliveConfig{
                        Time:    60 * time.Second,
                        Timeout: 20 * time.Second,
                },
                MaxRetries:   3,
                RetryWaitMin: 1 * time.Second,
                RetryWaitMax: 5 * time.Second,
        }
}</span>

// Client is a gRPC client with connection management and metrics capabilities
type Client struct {
        conn    *grpc.ClientConn
        config  Config
        metrics *MetricsReporter
}

// New creates a new gRPC client
func New(config Config, metricsReporter *metrics.Reporter) (*Client, error) <span class="cov10" title="2">{
        if config.Target == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("target address must be provided")
        }</span>

        <span class="cov1" title="1">dialOpts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithKeepaliveParams(keepalive.ClientParameters{
                        Time:                config.KeepAlive.Time,
                        Timeout:             config.KeepAlive.Timeout,
                        PermitWithoutStream: true,
                }),
        }

        ctx, cancel := context.WithTimeout(context.Background(), config.DialTimeout)
        defer cancel()

        conn, err := grpc.DialContext(ctx, config.Target, dialOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to dial server: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;Client{
                conn:    conn,
                config:  config,
                metrics: NewMetricsReporter(metricsReporter),
        }, nil</span>
}

// Close closes the gRPC client connection
func (c *Client) Close() error <span class="cov1" title="1">{
        if c.conn != nil </span><span class="cov1" title="1">{
                return c.conn.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Connection returns the underlying gRPC client connection
func (c *Client) Connection() *grpc.ClientConn <span class="cov0" title="0">{
        return c.conn
}</span>

// WithTimeout returns a context with the configured timeout
func (c *Client) WithTimeout(ctx context.Context) (context.Context, context.CancelFunc) <span class="cov1" title="1">{
        return context.WithTimeout(ctx, c.config.Timeout)
}</span>

// WithUnaryInterceptor returns a gRPC dial option that adds the unary interceptor
func (c *Client) WithUnaryInterceptor() grpc.DialOption <span class="cov1" title="1">{
        return grpc.WithUnaryInterceptor(c.unaryInterceptor())
}</span>

// WithStreamInterceptor returns a gRPC dial option that adds the stream interceptor
func (c *Client) WithStreamInterceptor() grpc.DialOption <span class="cov1" title="1">{
        return grpc.WithStreamInterceptor(c.streamInterceptor())
}</span>

// unaryInterceptor returns a gRPC unary interceptor that adds metrics and error handling
func (c *Client) unaryInterceptor() grpc.UnaryClientInterceptor <span class="cov1" title="1">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                start := time.Now()
                err := invoker(ctx, method, req, reply, cc, opts...)
                c.metrics.ObserveRequest(method, err, time.Since(start))
                return err
        }</span>
}

// streamInterceptor returns a gRPC stream interceptor that adds metrics and error handling
func (c *Client) streamInterceptor() grpc.StreamClientInterceptor <span class="cov1" title="1">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                start := time.Now()
                stream, err := streamer(ctx, desc, cc, method, opts...)
                c.metrics.ObserveRequest(method, err, time.Since(start))
                return stream, err
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package grpc

import (
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// MetricsReporter handles gRPC client metrics reporting
type MetricsReporter struct {
        requestDuration *prometheus.HistogramVec
        requestErrors   *prometheus.CounterVec
}

// NewMetricsReporter creates a new gRPC client metrics reporter
func NewMetricsReporter(reporter *metrics.Reporter) *MetricsReporter <span class="cov10" title="3">{
        return &amp;MetricsReporter{
                requestDuration: reporter.Histogram(
                        "grpc_client_request_duration_seconds",
                        "gRPC client request duration in seconds",
                        []string{"method", "status"},
                        []float64{0.01, 0.05, 0.1, 0.5, 1, 2.5, 5, 10},
                ),
                requestErrors: reporter.Counter(
                        "grpc_client_errors_total",
                        "Total number of gRPC client errors",
                        []string{"method"},
                ),
        }
}</span>

// ObserveRequest records a request execution
func (m *MetricsReporter) ObserveRequest(method string, err error, duration time.Duration) <span class="cov6" title="2">{
        status := "success"
        if err != nil </span><span class="cov1" title="1">{
                status = "error"
                m.requestErrors.WithLabelValues(method).Inc()
        }</span>
        <span class="cov6" title="2">m.requestDuration.WithLabelValues(method, status).Observe(duration.Seconds())</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package http

import (
        "context"
        "fmt"
        "io"
        "math"
        "net/http"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
)

// Config holds the HTTP client configuration
type Config struct {
        // Timeout is the maximum time to wait for a request to complete
        Timeout time.Duration `json:"timeout" yaml:"timeout"`
        // MaxRetries is the maximum number of retries for a request
        MaxRetries int `json:"max_retries" yaml:"max_retries"`
        // RetryWaitMin is the minimum time to wait between retries
        RetryWaitMin time.Duration `json:"retry_wait_min" yaml:"retry_wait_min"`
        // RetryWaitMax is the maximum time to wait between retries
        RetryWaitMax time.Duration `json:"retry_wait_max" yaml:"retry_wait_max"`
        // RetryableStatusCodes are HTTP status codes that should trigger a retry
        RetryableStatusCodes []int `json:"retryable_status_codes" yaml:"retryable_status_codes"`
}

// DefaultConfig returns the default HTTP client configuration
func DefaultConfig() Config <span class="cov5" title="6">{
        return Config{
                Timeout:              30 * time.Second,
                MaxRetries:           3,
                RetryWaitMin:         1 * time.Second,
                RetryWaitMax:         5 * time.Second,
                RetryableStatusCodes: []int{408, 429, 500, 502, 503, 504},
        }
}</span>

// Client is an HTTP client with retry and metrics capabilities
type Client struct {
        client  *http.Client
        config  Config
        metrics *MetricsReporter
}

// New creates a new HTTP client
func New(config Config, metricsReporter *metrics.Reporter) *Client <span class="cov5" title="5">{
        client := &amp;http.Client{
                Timeout: config.Timeout,
        }

        return &amp;Client{
                client:  client,
                config:  config,
                metrics: NewMetricsReporter(metricsReporter),
        }
}</span>

// Do sends an HTTP request and returns an HTTP response
func (c *Client) Do(req *http.Request) (*http.Response, error) <span class="cov5" title="5">{
        ctx := req.Context()
        var resp *http.Response
        var err error

        start := time.Now()
        defer func() </span><span class="cov5" title="5">{
                c.metrics.ObserveRequest(req.Method, resp, err, time.Since(start))
        }</span>()

        <span class="cov5" title="5">for i := 0; i &lt;= c.config.MaxRetries; i++ </span><span class="cov7" title="15">{
                resp, err = c.client.Do(req)
                if err != nil </span><span class="cov6" title="8">{
                        c.metrics.ObserveError("request_failed")
                        if i == c.config.MaxRetries </span><span class="cov2" title="2">{
                                return nil, fmt.Errorf("max retries reached: %w", err)
                        }</span>
                        <span class="cov5" title="6">continue</span>
                }

                <span class="cov5" title="7">if !c.shouldRetry(resp.StatusCode) </span><span class="cov2" title="2">{
                        return resp, nil
                }</span>

                <span class="cov5" title="5">if i == c.config.MaxRetries </span><span class="cov1" title="1">{
                        return resp, nil
                }</span>

                // Close the response body before retrying
                <span class="cov4" title="4">if resp.Body != nil </span><span class="cov4" title="4">{
                        resp.Body.Close()
                }</span>

                // Wait before retrying
                <span class="cov4" title="4">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(c.getRetryBackoff(i)):<span class="cov4" title="4">
                        continue</span>
                }
        }

        <span class="cov0" title="0">return resp, err</span>
}

// Get sends a GET request to the specified URL
func (c *Client) Get(ctx context.Context, url string) (*http.Response, error) <span class="cov4" title="4">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="4">return c.Do(req)</span>
}

// Post sends a POST request to the specified URL
func (c *Client) Post(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) <span class="cov1" title="1">{
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">req.Header.Set("Content-Type", contentType)
        return c.Do(req)</span>
}

// shouldRetry returns true if the status code is retryable
func (c *Client) shouldRetry(statusCode int) bool <span class="cov5" title="7">{
        for _, code := range c.config.RetryableStatusCodes </span><span class="cov10" title="37">{
                if statusCode == code </span><span class="cov5" title="5">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// getRetryBackoff returns the backoff duration for a retry attempt
func (c *Client) getRetryBackoff(attempt int) time.Duration <span class="cov4" title="4">{
        // Simple exponential backoff with jitter
        backoff := c.config.RetryWaitMin.Seconds() * math.Pow(2, float64(attempt))
        if backoff &gt; c.config.RetryWaitMax.Seconds() </span><span class="cov0" title="0">{
                backoff = c.config.RetryWaitMax.Seconds()
        }</span>
        // Add jitter by varying the backoff by 25%
        <span class="cov4" title="4">jitter := (backoff * 0.5) - (backoff * 0.25)
        return time.Duration((backoff + jitter) * float64(time.Second))</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package http

import (
        "net/http"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/prometheus/client_golang/prometheus"
)

// MetricsReporter handles HTTP client metrics reporting
type MetricsReporter struct {
        requestDuration *prometheus.HistogramVec
        requestErrors   *prometheus.CounterVec
}

// NewMetricsReporter creates a new HTTP client metrics reporter
func NewMetricsReporter(reporter *metrics.Reporter) *MetricsReporter <span class="cov8" title="6">{
        return &amp;MetricsReporter{
                requestDuration: reporter.Histogram(
                        "http_client_request_duration_seconds",
                        "HTTP client request duration in seconds",
                        []string{"method", "status"},
                        []float64{0.01, 0.05, 0.1, 0.5, 1, 2.5, 5, 10},
                ),
                requestErrors: reporter.Counter(
                        "http_client_errors_total",
                        "Total number of HTTP client errors",
                        []string{"type"},
                ),
        }
}</span>

// ObserveRequest records a request execution
func (m *MetricsReporter) ObserveRequest(method string, resp *http.Response, err error, duration time.Duration) <span class="cov8" title="7">{
        status := "error"
        if err == nil &amp;&amp; resp != nil </span><span class="cov6" title="4">{
                status = "success"
        }</span>
        <span class="cov8" title="7">m.requestDuration.WithLabelValues(method, status).Observe(duration.Seconds())</span>
}

// ObserveError records a client error
func (m *MetricsReporter) ObserveError(errorType string) <span class="cov10" title="10">{
        m.requestErrors.WithLabelValues(errorType).Inc()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package logging

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/google/uuid"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
)

// TraceID represents a unique identifier for request tracing
type TraceID string

// ContextKey is used for storing values in context
type ContextKey string

const (
        // TraceIDKey is the key used to store trace IDs in context
        TraceIDKey ContextKey = "trace_id"
        // UserIDKey is the key used to store user IDs in context
        UserIDKey ContextKey = "user_id"
        // RequestIDKey is the key used to store request IDs in context
        RequestIDKey ContextKey = "request_id"
)

// AdvancedConfig extends the basic Config with additional options
type AdvancedConfig struct {
        Config
        // Rotation settings
        MaxSize    int  `json:"max_size"`    // Maximum size in megabytes before rotation
        MaxBackups int  `json:"max_backups"` // Maximum number of old log files to retain
        MaxAge     int  `json:"max_age"`     // Maximum number of days to retain old log files
        Compress   bool `json:"compress"`    // Compress rotated files
        // Sampling settings
        SampleInitial    int `json:"sample_initial"`    // Sample up to n entries per second
        SampleThereafter int `json:"sample_thereafter"` // Sample every nth entry after initial
}

// DefaultAdvancedConfig returns default advanced logger configuration
func DefaultAdvancedConfig() AdvancedConfig <span class="cov1" title="1">{
        return AdvancedConfig{
                Config:           DefaultConfig(),
                MaxSize:          100,
                MaxBackups:       3,
                MaxAge:           28,
                Compress:         true,
                SampleInitial:    100,
                SampleThereafter: 100,
        }
}</span>

// NewAdvanced creates a new logger with advanced features
func NewAdvanced(cfg AdvancedConfig) (*Logger, error) <span class="cov1" title="1">{
        level, err := parseLevel(cfg.Level)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create the log directory if it doesn't exist
        <span class="cov1" title="1">if cfg.OutputPath != "stdout" &amp;&amp; cfg.OutputPath != "stderr" </span><span class="cov1" title="1">{
                dir := filepath.Dir(cfg.OutputPath)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create log directory: %w", err)
                }</span>
        }

        // Configure log rotation if not writing to stdout/stderr
        <span class="cov1" title="1">var output zapcore.WriteSyncer
        if cfg.OutputPath == "stdout" </span><span class="cov0" title="0">{
                output = zapcore.AddSync(os.Stdout)
        }</span> else<span class="cov1" title="1"> if cfg.OutputPath == "stderr" </span><span class="cov0" title="0">{
                output = zapcore.AddSync(os.Stderr)
        }</span> else<span class="cov1" title="1"> {
                output = zapcore.AddSync(&amp;lumberjack.Logger{
                        Filename:   cfg.OutputPath,
                        MaxSize:    cfg.MaxSize,
                        MaxBackups: cfg.MaxBackups,
                        MaxAge:     cfg.MaxAge,
                        Compress:   cfg.Compress,
                })
        }</span>

        <span class="cov1" title="1">encoderConfig := defaultEncoderConfig()
        var encoder zapcore.Encoder
        if cfg.Encoding == "json" </span><span class="cov1" title="1">{
                encoder = zapcore.NewJSONEncoder(encoderConfig)
        }</span> else<span class="cov0" title="0"> {
                encoder = zapcore.NewConsoleEncoder(encoderConfig)
        }</span>

        <span class="cov1" title="1">core := zapcore.NewSamplerWithOptions(
                zapcore.NewCore(encoder, output, level),
                time.Second,
                cfg.SampleInitial,
                cfg.SampleThereafter,
        )

        logger := zap.New(core,
                zap.AddCaller(),
                zap.AddStacktrace(zapcore.ErrorLevel),
        )

        return &amp;Logger{zap: logger}, nil</span>
}

// WithTracing adds request tracing to the logger
func (l *Logger) WithTracing() *Logger <span class="cov1" title="1">{
        traceID := TraceID(uuid.New().String())
        return l.With(zap.String("trace_id", string(traceID)))
}</span>

// FromContext extracts logging fields from context
func (l *Logger) FromContext(ctx context.Context) *Logger <span class="cov6" title="2">{
        logger := l

        // Extract trace ID
        if traceID, ok := ctx.Value(TraceIDKey).(TraceID); ok </span><span class="cov1" title="1">{
                logger = logger.With(zap.String("trace_id", string(traceID)))
        }</span>

        // Extract user ID
        <span class="cov6" title="2">if userID, ok := ctx.Value(UserIDKey).(string); ok </span><span class="cov6" title="2">{
                logger = logger.With(zap.String("user_id", userID))
        }</span>

        // Extract request ID
        <span class="cov6" title="2">if requestID, ok := ctx.Value(RequestIDKey).(string); ok </span><span class="cov1" title="1">{
                logger = logger.With(zap.String("request_id", requestID))
        }</span>

        <span class="cov6" title="2">return logger</span>
}

// HTTPMiddleware creates a middleware that adds request information to the logger
func (l *Logger) HTTPMiddleware(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov1" title="1">{
                start := time.Now()

                // Generate trace ID and request ID
                traceID := TraceID(uuid.New().String())
                requestID := uuid.New().String()

                // Add IDs to context
                ctx := context.WithValue(r.Context(), TraceIDKey, traceID)
                ctx = context.WithValue(ctx, RequestIDKey, requestID)

                // Create request-scoped logger
                reqLogger := l.With(
                        zap.String("trace_id", string(traceID)),
                        zap.String("request_id", requestID),
                        zap.String("method", r.Method),
                        zap.String("path", r.URL.Path),
                        zap.String("remote_addr", r.RemoteAddr),
                        zap.String("user_agent", r.UserAgent()),
                )

                // Log request
                reqLogger.Info("Request started")

                // Call next handler with updated context
                next.ServeHTTP(w, r.WithContext(ctx))

                // Log request completion
                reqLogger.Info("Request completed",
                        zap.Duration("duration", time.Since(start)),
                )
        }</span>)
}

// Audit logs an audit event with user and action information
func (l *Logger) Audit(ctx context.Context, action string, details map[string]interface{}) <span class="cov1" title="1">{
        logger := l.FromContext(ctx)

        fields := make([]zapcore.Field, 0, len(details)+1)
        fields = append(fields, zap.String("action", action))

        for k, v := range details </span><span class="cov10" title="3">{
                fields = append(fields, zap.Any(k, v))
        }</span>

        <span class="cov1" title="1">logger.Info("Audit event", fields...)</span>
}

// LogMetric logs a metric with the given name and value
func (l *Logger) LogMetric(name string, value interface{}, tags map[string]string) <span class="cov1" title="1">{
        fields := make([]zapcore.Field, 0, len(tags)+2)
        fields = append(fields, zap.String("metric_name", name))
        fields = append(fields, zap.Any("metric_value", value))

        for k, v := range tags </span><span class="cov6" title="2">{
                fields = append(fields, zap.String(k, v))
        }</span>

        <span class="cov1" title="1">l.Info("Metric", fields...)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package logging

import (
        "context"
        "errors"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Level represents the logging level
type Level string

const (
        // Debug level for development
        Debug Level = "debug"
        // Info level for general operational entries
        Info Level = "info"
        // Warn level for non-critical issues
        Warn Level = "warn"
        // Error level for errors that need attention
        Error Level = "error"
)

// Logger wraps zap logger with additional functionality
type Logger struct {
        zap *zap.Logger
}

// Config holds logger configuration
type Config struct {
        Level      Level  `json:"level"`
        OutputPath string `json:"output_path"`
        Encoding   string `json:"encoding"`
}

// DefaultConfig returns default logger configuration
func DefaultConfig() Config <span class="cov2" title="2">{
        return Config{
                Level:      Info,
                OutputPath: "stdout",
                Encoding:   "json",
        }
}</span>

// New creates a new logger instance
func New(cfg Config) (*Logger, error) <span class="cov1" title="1">{
        level, err := parseLevel(cfg.Level)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">zapCfg := zap.Config{
                Level:       zap.NewAtomicLevelAt(level),
                Development: false,
                Sampling: &amp;zap.SamplingConfig{
                        Initial:    100,
                        Thereafter: 100,
                },
                Encoding:         cfg.Encoding,
                EncoderConfig:    defaultEncoderConfig(),
                OutputPaths:      []string{cfg.OutputPath},
                ErrorOutputPaths: []string{cfg.OutputPath},
        }

        logger, err := zapCfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;Logger{zap: logger}, nil</span>
}

// NewFromZap creates a new logger instance from an existing zap logger
func NewFromZap(zapLogger *zap.Logger) (*Logger, error) <span class="cov5" title="5">{
        if zapLogger == nil </span><span class="cov1" title="1">{
                return nil, errors.New("zap logger cannot be nil")
        }</span>
        <span class="cov4" title="4">return &amp;Logger{zap: zapLogger}, nil</span>
}

// With creates a child logger with additional fields
func (l *Logger) With(fields ...zapcore.Field) *Logger <span class="cov7" title="10">{
        return &amp;Logger{zap: l.zap.With(fields...)}
}</span>

// Debug logs a message at debug level
func (l *Logger) Debug(msg string, fields ...zapcore.Field) <span class="cov1" title="1">{
        l.zap.Debug(msg, fields...)
}</span>

// Info logs a message at info level
func (l *Logger) Info(msg string, fields ...zapcore.Field) <span class="cov10" title="31">{
        l.zap.Info(msg, fields...)
}</span>

// Warn logs a message at warn level
func (l *Logger) Warn(msg string, fields ...zapcore.Field) <span class="cov2" title="2">{
        l.zap.Warn(msg, fields...)
}</span>

// Error logs a message at error level
func (l *Logger) Error(msg string, fields ...zapcore.Field) <span class="cov3" title="3">{
        l.zap.Error(msg, fields...)
}</span>

// WithContext returns a logger with context fields
func (l *Logger) WithContext(ctx context.Context) *Logger <span class="cov5" title="6">{
        // TODO: Extract relevant fields from context
        return l
}</span>

// Sync flushes any buffered log entries
func (l *Logger) Sync() error <span class="cov1" title="1">{
        return l.zap.Sync()
}</span>

func parseLevel(level Level) (zapcore.Level, error) <span class="cov2" title="2">{
        switch level </span>{
        case Debug:<span class="cov0" title="0">
                return zapcore.DebugLevel, nil</span>
        case Info:<span class="cov2" title="2">
                return zapcore.InfoLevel, nil</span>
        case Warn:<span class="cov0" title="0">
                return zapcore.WarnLevel, nil</span>
        case Error:<span class="cov0" title="0">
                return zapcore.ErrorLevel, nil</span>
        default:<span class="cov0" title="0">
                return zapcore.InfoLevel, nil</span>
        }
}

func defaultEncoderConfig() zapcore.EncoderConfig <span class="cov6" title="9">{
        return zapcore.EncoderConfig{
                TimeKey:        "ts",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.LowercaseLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package testing

import (
        "io"

        "github.com/StackCatalyst/common-lib/pkg/logging"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewTestLogger creates a new logger instance for testing that writes to the provided writer
func NewTestLogger(w io.Writer) (*logging.Logger, error) <span class="cov10" title="3">{
        encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "ts",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.LowercaseLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        core := zapcore.NewCore(
                zapcore.NewJSONEncoder(encoderConfig),
                zapcore.AddSync(w),
                zapcore.DebugLevel,
        )

        return logging.NewFromZap(zap.New(core))
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package metrics

import (
        "context"
        "runtime"
        "strconv"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/mem"
)

// ServiceHealth represents service health metrics
type ServiceHealth struct {
        reporter    *Reporter
        status      *prometheus.GaugeVec
        uptime      prometheus.Gauge
        lastChecked prometheus.Gauge
}

// ResourceMetrics represents system resource metrics
type ResourceMetrics struct {
        reporter     *Reporter
        cpuUsage     *prometheus.GaugeVec
        memoryUsage  *prometheus.GaugeVec
        goroutines   prometheus.Gauge
        allocatedMem prometheus.Gauge
}

// NewServiceHealth creates a new service health metrics collector
func NewServiceHealth(r *Reporter) *ServiceHealth <span class="cov1" title="1">{
        status := r.Gauge(
                "service_health_status",
                "Current health status of the service (0: unhealthy, 1: healthy)",
                []string{"service", "instance"},
        )

        uptimeVec := r.Gauge(
                "service_uptime_seconds",
                "Time since service start in seconds",
                []string{},
        )

        lastCheckedVec := r.Gauge(
                "service_health_last_checked_timestamp",
                "Unix timestamp of the last health check",
                []string{},
        )

        return &amp;ServiceHealth{
                reporter:    r,
                status:      status,
                uptime:      uptimeVec.WithLabelValues(),
                lastChecked: lastCheckedVec.WithLabelValues(),
        }
}</span>

// SetHealth updates the service health status
func (h *ServiceHealth) SetHealth(service, instance string, healthy bool) <span class="cov6" title="4">{
        value := 0.0
        if healthy </span><span class="cov3" title="2">{
                value = 1.0
        }</span>
        <span class="cov6" title="4">h.status.WithLabelValues(service, instance).Set(value)
        h.lastChecked.Set(float64(time.Now().Unix()))</span>
}

// UpdateUptime updates the service uptime
func (h *ServiceHealth) UpdateUptime(startTime time.Time) <span class="cov3" title="2">{
        h.uptime.Set(time.Since(startTime).Seconds())
}</span>

// NewResourceMetrics creates a new resource metrics collector
func NewResourceMetrics(r *Reporter) *ResourceMetrics <span class="cov1" title="1">{
        cpuUsage := r.Gauge(
                "system_cpu_usage",
                "CPU usage percentage per core",
                []string{"core"},
        )

        memoryUsage := r.Gauge(
                "system_memory_usage",
                "Memory usage statistics in bytes",
                []string{"type"},
        )

        goroutinesVec := r.Gauge(
                "go_goroutines_current",
                "Current number of goroutines",
                []string{},
        )

        allocatedMemVec := r.Gauge(
                "go_memory_allocated_bytes",
                "Currently allocated memory in bytes",
                []string{},
        )

        return &amp;ResourceMetrics{
                reporter:     r,
                cpuUsage:     cpuUsage,
                memoryUsage:  memoryUsage,
                goroutines:   goroutinesVec.WithLabelValues(),
                allocatedMem: allocatedMemVec.WithLabelValues(),
        }
}</span>

// CollectMetrics gathers all resource metrics
func (rm *ResourceMetrics) CollectMetrics(ctx context.Context) error <span class="cov1" title="1">{
        // Collect CPU metrics
        cpuPercent, err := cpu.PercentWithContext(ctx, 0, true)
        if err == nil </span><span class="cov1" title="1">{
                for i, usage := range cpuPercent </span><span class="cov10" title="12">{
                        rm.cpuUsage.WithLabelValues(strconv.Itoa(i)).Set(usage)
                }</span>
        }

        // Collect memory metrics
        <span class="cov1" title="1">if vmStat, err := mem.VirtualMemoryWithContext(ctx); err == nil </span><span class="cov1" title="1">{
                rm.memoryUsage.WithLabelValues("total").Set(float64(vmStat.Total))
                rm.memoryUsage.WithLabelValues("used").Set(float64(vmStat.Used))
                rm.memoryUsage.WithLabelValues("free").Set(float64(vmStat.Free))
                rm.memoryUsage.WithLabelValues("cached").Set(float64(vmStat.Cached))
        }</span>

        // Collect Go runtime metrics
        <span class="cov1" title="1">rm.goroutines.Set(float64(runtime.NumGoroutine()))
        var memStats runtime.MemStats
        runtime.ReadMemStats(&amp;memStats)
        rm.allocatedMem.Set(float64(memStats.Alloc))

        return nil</span>
}

// CustomCollector represents a custom metrics collector
type CustomCollector struct {
        metrics []prometheus.Collector
        collect func(context.Context) error
}

// NewCustomCollector creates a new custom metrics collector
func NewCustomCollector(metrics []prometheus.Collector, collectFunc func(context.Context) error) *CustomCollector <span class="cov1" title="1">{
        return &amp;CustomCollector{
                metrics: metrics,
                collect: collectFunc,
        }
}</span>

// Register registers the collector and its metrics with a registry
func (c *CustomCollector) Register(registry prometheus.Registerer) error <span class="cov1" title="1">{
        return registry.Register(c)
}</span>

// Describe implements prometheus.Collector
func (c *CustomCollector) Describe(ch chan&lt;- *prometheus.Desc) {<span class="cov1" title="1">
        // Do nothing, as metrics are already registered by the reporter
}</span>

// Collect implements prometheus.Collector
func (c *CustomCollector) Collect(ch chan&lt;- prometheus.Metric) <span class="cov1" title="1">{
        if err := c.collect(context.Background()); err != nil </span><span class="cov0" title="0">{
                // Log error but continue collecting other metrics
                return
        }</span>
        <span class="cov1" title="1">for _, m := range c.metrics </span><span class="cov1" title="1">{
                m.Collect(ch)
        }</span>
}

// Describe implements prometheus.Collector
func (h *ServiceHealth) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov1" title="1">{
        h.status.Describe(ch)
        ch &lt;- h.uptime.Desc()
        ch &lt;- h.lastChecked.Desc()
}</span>

// Collect implements prometheus.Collector
func (h *ServiceHealth) Collect(ch chan&lt;- prometheus.Metric) <span class="cov1" title="1">{
        h.status.Collect(ch)
        ch &lt;- h.uptime
        ch &lt;- h.lastChecked
}</span>

// Register registers the collector with a registry
func (h *ServiceHealth) Register(registry prometheus.Registerer) error <span class="cov0" title="0">{
        return registry.Register(h)
}</span>

// Describe implements prometheus.Collector
func (rm *ResourceMetrics) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov0" title="0">{
        rm.cpuUsage.Describe(ch)
        rm.memoryUsage.Describe(ch)
        ch &lt;- rm.goroutines.Desc()
        ch &lt;- rm.allocatedMem.Desc()
}</span>

// Collect implements prometheus.Collector
func (rm *ResourceMetrics) Collect(ch chan&lt;- prometheus.Metric) <span class="cov0" title="0">{
        rm.cpuUsage.Collect(ch)
        rm.memoryUsage.Collect(ch)
        ch &lt;- rm.goroutines
        ch &lt;- rm.allocatedMem
}</span>

// Register registers the collector with a registry
func (rm *ResourceMetrics) Register(registry prometheus.Registerer) error <span class="cov0" title="0">{
        return registry.Register(rm)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package metrics

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// CollectorConfig represents the configuration for the metrics collector
type CollectorConfig struct {
        // ListenAddress is the address where the metrics HTTP server will listen
        ListenAddress string
        // Path is the HTTP path where metrics will be exposed
        Path string
        // CollectionInterval is the interval between metric collections
        CollectionInterval time.Duration
        // Labels are the default labels to be added to all metrics
        Labels map[string]string
}

// DefaultCollectorConfig returns the default collector configuration
func DefaultCollectorConfig() CollectorConfig <span class="cov0" title="0">{
        return CollectorConfig{
                ListenAddress:      ":9090",
                Path:               "/metrics",
                CollectionInterval: 15 * time.Second,
                Labels: map[string]string{
                        "service": "unknown",
                        "env":     "unknown",
                },
        }
}</span>

// MetricsCollector manages metric collection and exposition
type MetricsCollector struct {
        config    CollectorConfig
        registry  *prometheus.Registry
        reporter  *Reporter
        health    *ServiceHealth
        resources *ResourceMetrics
        custom    []*CustomCollector
        server    *http.Server
        mu        sync.RWMutex
}

// NewCollector creates a new metrics collector
func NewCollector(config CollectorConfig) (*MetricsCollector, error) <span class="cov0" title="0">{
        registry := prometheus.NewRegistry()
        reporter := &amp;Reporter{
                registry: registry,
                factory:  promauto.With(registry),
        }

        collector := &amp;MetricsCollector{
                config:    config,
                registry:  registry,
                reporter:  reporter,
                health:    NewServiceHealth(reporter),
                resources: NewResourceMetrics(reporter),
                custom:    make([]*CustomCollector, 0),
        }

        // Register default collectors
        registry.MustRegister(
                prometheus.NewProcessCollector(prometheus.ProcessCollectorOpts{}),
                prometheus.NewGoCollector(),
        )

        return collector, nil
}</span>

// RegisterCustomCollector adds a custom collector
func (c *MetricsCollector) RegisterCustomCollector(collector *CustomCollector) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if err := c.registry.Register(collector); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register custom collector: %w", err)
        }</span>
        <span class="cov0" title="0">c.custom = append(c.custom, collector)
        return nil</span>
}

// Start begins collecting and exposing metrics
func (c *MetricsCollector) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Set up HTTP server
        mux := http.NewServeMux()
        mux.Handle(c.config.Path, promhttp.HandlerFor(c.registry, promhttp.HandlerOpts{
                EnableOpenMetrics: true,
        }))

        c.server = &amp;http.Server{
                Addr:    c.config.ListenAddress,
                Handler: mux,
        }

        // Start collection loop
        go c.collect(ctx)

        // Start HTTP server
        go func() </span><span class="cov0" title="0">{
                if err := c.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        fmt.Printf("Metrics server error: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully shuts down the metrics collector
func (c *MetricsCollector) Stop(ctx context.Context) error <span class="cov0" title="0">{
        if c.server != nil </span><span class="cov0" title="0">{
                return c.server.Shutdown(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// collect periodically collects metrics
func (c *MetricsCollector) collect(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(c.config.CollectionInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := c.resources.CollectMetrics(ctx); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error collecting resource metrics: %v\n", err)
                        }</span>

                        <span class="cov0" title="0">c.mu.RLock()
                        for _, collector := range c.custom </span><span class="cov0" title="0">{
                                if err := collector.collect(ctx); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Error collecting custom metrics: %v\n", err)
                                }</span>
                        }
                        <span class="cov0" title="0">c.mu.RUnlock()</span>
                }
        }
}

// GetRegistry returns the Prometheus registry
func (c *MetricsCollector) GetRegistry() *prometheus.Registry <span class="cov0" title="0">{
        return c.registry
}</span>

// GetReporter returns the metrics reporter
func (c *MetricsCollector) GetReporter() *Reporter <span class="cov0" title="0">{
        return c.reporter
}</span>

// GetHealth returns the service health metrics
func (c *MetricsCollector) GetHealth() *ServiceHealth <span class="cov0" title="0">{
        return c.health
}</span>

// GetResources returns the resource metrics
func (c *MetricsCollector) GetResources() *ResourceMetrics <span class="cov0" title="0">{
        return c.resources
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

// Reporter handles metrics reporting
type Reporter struct {
        registry  prometheus.Registerer
        factory   promauto.Factory
        namespace string
        subsystem string
}

// Options configures the metrics reporter
type Options struct {
        // Namespace is the metrics namespace (e.g., "terraorbit")
        Namespace string
        // Subsystem is the metrics subsystem (e.g., "auth")
        Subsystem string
        // Registry is an optional custom Prometheus registry
        Registry prometheus.Registerer
}

// DefaultOptions returns the default metrics options
func DefaultOptions() Options <span class="cov3" title="3">{
        return Options{
                Namespace: "terraorbit",
                Subsystem: "",
                Registry:  prometheus.DefaultRegisterer,
        }
}</span>

// New creates a new metrics reporter
func New(opts Options) *Reporter <span class="cov9" title="36">{
        if opts.Registry == nil </span><span class="cov0" title="0">{
                opts.Registry = prometheus.DefaultRegisterer
        }</span>

        <span class="cov9" title="36">factory := promauto.With(opts.Registry)
        return &amp;Reporter{
                registry:  opts.Registry,
                factory:   factory,
                namespace: opts.Namespace,
                subsystem: opts.Subsystem,
        }</span>
}

// Counter creates a new counter metric
func (r *Reporter) Counter(name, help string, labels []string) *prometheus.CounterVec <span class="cov10" title="56">{
        return r.factory.NewCounterVec(
                prometheus.CounterOpts{
                        Namespace: r.namespace,
                        Subsystem: r.subsystem,
                        Name:      name,
                        Help:      help,
                },
                labels,
        )
}</span>

// Gauge creates a new gauge metric
func (r *Reporter) Gauge(name, help string, labels []string) *prometheus.GaugeVec <span class="cov8" title="29">{
        return r.factory.NewGaugeVec(
                prometheus.GaugeOpts{
                        Namespace: r.namespace,
                        Subsystem: r.subsystem,
                        Name:      name,
                        Help:      help,
                },
                labels,
        )
}</span>

// Histogram creates a new histogram metric
func (r *Reporter) Histogram(name, help string, labels []string, buckets []float64) *prometheus.HistogramVec <span class="cov9" title="36">{
        return r.factory.NewHistogramVec(
                prometheus.HistogramOpts{
                        Namespace: r.namespace,
                        Subsystem: r.subsystem,
                        Name:      name,
                        Help:      help,
                        Buckets:   buckets,
                },
                labels,
        )
}</span>

// Summary creates a new summary metric
func (r *Reporter) Summary(name, help string, labels []string, objectives map[float64]float64) *prometheus.SummaryVec <span class="cov2" title="2">{
        return r.factory.NewSummaryVec(
                prometheus.SummaryOpts{
                        Namespace:  r.namespace,
                        Subsystem:  r.subsystem,
                        Name:       name,
                        Help:       help,
                        Objectives: objectives,
                },
                labels,
        )
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package metrics

import "time"

// Standard label names
const (
        LabelService     = "service"
        LabelInstance    = "instance"
        LabelEnvironment = "environment"
        LabelVersion     = "version"
        LabelEndpoint    = "endpoint"
        LabelMethod      = "method"
        LabelStatusCode  = "status_code"
        LabelErrorType   = "error_type"
        LabelComponent   = "component"
)

// Standard metric names
const (
        // HTTP metrics
        MetricHTTPRequestsTotal          = "http_requests_total"
        MetricHTTPRequestDurationSeconds = "http_request_duration_seconds"
        MetricHTTPRequestSizeBytes       = "http_request_size_bytes"
        MetricHTTPResponseSizeBytes      = "http_response_size_bytes"
        MetricHTTPRequestsInFlight       = "http_requests_in_flight"

        // Database metrics
        MetricDBConnectionsTotal     = "db_connections_total"
        MetricDBConnectionsInUse     = "db_connections_in_use"
        MetricDBQueryDurationSeconds = "db_query_duration_seconds"
        MetricDBErrorsTotal          = "db_errors_total"
        MetricDBTransactionsTotal    = "db_transactions_total"

        // Cache metrics
        MetricCacheHitsTotal                = "cache_hits_total"
        MetricCacheMissesTotal              = "cache_misses_total"
        MetricCacheItemsTotal               = "cache_items_total"
        MetricCacheSizeBytes                = "cache_size_bytes"
        MetricCacheOperationDurationSeconds = "cache_operation_duration_seconds"

        // Service metrics
        MetricServiceUptime       = "service_uptime_seconds"
        MetricServiceHealth       = "service_health_status"
        MetricServiceLastCheck    = "service_last_check_timestamp"
        MetricServiceDependencyUp = "service_dependency_up"

        // Resource metrics
        MetricCPUUsagePercent   = "cpu_usage_percent"
        MetricMemoryUsageBytes  = "memory_usage_bytes"
        MetricGoroutinesTotal   = "goroutines_total"
        MetricGCDurationSeconds = "gc_duration_seconds"
        MetricHeapSizeBytes     = "heap_size_bytes"
)

// Standard buckets for histograms
var (
        // DurationBuckets are suitable for measuring HTTP request, database query,
        // and other operation durations in seconds
        DurationBuckets = []float64{
                .005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10,
        }

        // SizeBuckets are suitable for measuring sizes (request, response, payload)
        // in bytes
        SizeBuckets = []float64{
                256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536,
        }
)

// StandardLabels returns a set of standard labels for a service
type StandardLabels struct {
        Service     string
        Instance    string
        Environment string
        Version     string
}

// ToMap converts StandardLabels to a map
func (l StandardLabels) ToMap() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                LabelService:     l.Service,
                LabelInstance:    l.Instance,
                LabelEnvironment: l.Environment,
                LabelVersion:     l.Version,
        }
}</span>

// MetricDefinition represents a standard metric definition
type MetricDefinition struct {
        Name       string
        Help       string
        Type       string // "counter", "gauge", "histogram", "summary"
        Labels     []string
        Buckets    []float64           // for histograms
        Objectives map[float64]float64 // for summaries
        MaxAge     time.Duration       // for summaries
}

// StandardMetrics returns a map of standard metric definitions
func StandardMetrics() map[string]MetricDefinition <span class="cov0" title="0">{
        return map[string]MetricDefinition{
                MetricHTTPRequestsTotal: {
                        Name:   MetricHTTPRequestsTotal,
                        Help:   "Total number of HTTP requests",
                        Type:   "counter",
                        Labels: []string{LabelService, LabelEndpoint, LabelMethod, LabelStatusCode},
                },
                MetricHTTPRequestDurationSeconds: {
                        Name:    MetricHTTPRequestDurationSeconds,
                        Help:    "HTTP request duration in seconds",
                        Type:    "histogram",
                        Labels:  []string{LabelService, LabelEndpoint, LabelMethod},
                        Buckets: DurationBuckets,
                },
                MetricDBQueryDurationSeconds: {
                        Name:    MetricDBQueryDurationSeconds,
                        Help:    "Database query duration in seconds",
                        Type:    "histogram",
                        Labels:  []string{LabelService, LabelComponent},
                        Buckets: DurationBuckets,
                },
                MetricCacheHitsTotal: {
                        Name:   MetricCacheHitsTotal,
                        Help:   "Total number of cache hits",
                        Type:   "counter",
                        Labels: []string{LabelService, LabelComponent},
                },
                MetricServiceHealth: {
                        Name:   MetricServiceHealth,
                        Help:   "Current health status (0 = unhealthy, 1 = healthy)",
                        Type:   "gauge",
                        Labels: []string{LabelService, LabelInstance},
                },
        }
}</span>

// NewStandardReporter creates a Reporter with standard metrics pre-registered
func NewStandardReporter(opts Options, labels StandardLabels) *Reporter <span class="cov0" title="0">{
        reporter := New(opts)
        metrics := StandardMetrics()

        // Pre-register standard metrics
        for _, metric := range metrics </span><span class="cov0" title="0">{
                allLabels := append([]string{}, metric.Labels...)
                switch metric.Type </span>{
                case "counter":<span class="cov0" title="0">
                        reporter.Counter(metric.Name, metric.Help, allLabels)</span>
                case "gauge":<span class="cov0" title="0">
                        reporter.Gauge(metric.Name, metric.Help, allLabels)</span>
                case "histogram":<span class="cov0" title="0">
                        reporter.Histogram(metric.Name, metric.Help, allLabels, metric.Buckets)</span>
                case "summary":<span class="cov0" title="0">
                        reporter.Summary(metric.Name, metric.Help, allLabels, metric.Objectives)</span>
                }
        }

        <span class="cov0" title="0">return reporter</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package docs

import (
        "bytes"
        "fmt"
        "html/template"
        "strings"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/module"
)

// Format represents the documentation output format
type Format string

const (
        // FormatMarkdown generates documentation in Markdown format
        FormatMarkdown Format = "markdown"
        // FormatHTML generates documentation in HTML format
        FormatHTML Format = "html"
)

// Generator generates documentation for modules
type Generator interface {
        // Generate creates documentation for a module
        Generate(mod *module.Module, format Format) ([]byte, error)

        // GenerateIndex creates an index of all modules
        GenerateIndex(modules []*module.Module, format Format) ([]byte, error)
}

// DefaultGenerator is the default implementation of Generator
type DefaultGenerator struct {
        moduleTemplates map[Format]*template.Template
        indexTemplates  map[Format]*template.Template
}

// NewGenerator creates a new documentation generator
func NewGenerator() Generator <span class="cov1" title="1">{
        return &amp;DefaultGenerator{
                moduleTemplates: make(map[Format]*template.Template),
                indexTemplates:  make(map[Format]*template.Template),
        }
}</span>

// Generate creates documentation for a module
func (g *DefaultGenerator) Generate(mod *module.Module, format Format) ([]byte, error) <span class="cov7" title="3">{
        tmpl, err := g.getTemplate(format)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get template: %w", err)
        }</span>

        <span class="cov4" title="2">data := struct {
                Module    *module.Module
                Generated time.Time
        }{
                Module:    mod,
                Generated: time.Now(),
        }

        var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov4" title="2">return buf.Bytes(), nil</span>
}

// GenerateIndex creates an index of all modules
func (g *DefaultGenerator) GenerateIndex(modules []*module.Module, format Format) ([]byte, error) <span class="cov7" title="3">{
        tmpl, err := g.getIndexTemplate(format)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get index template: %w", err)
        }</span>

        <span class="cov4" title="2">data := struct {
                Modules   []*module.Module
                Generated time.Time
        }{
                Modules:   modules,
                Generated: time.Now(),
        }

        var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov4" title="2">return buf.Bytes(), nil</span>
}

// getTemplate returns the template for the specified format
func (g *DefaultGenerator) getTemplate(format Format) (*template.Template, error) <span class="cov7" title="3">{
        if tmpl, ok := g.moduleTemplates[format]; ok </span><span class="cov0" title="0">{
                return tmpl, nil
        }</span>

        <span class="cov7" title="3">var content string
        switch format </span>{
        case FormatMarkdown:<span class="cov1" title="1">
                content = markdownTemplate</span>
        case FormatHTML:<span class="cov1" title="1">
                content = htmlTemplate</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }

        <span class="cov4" title="2">tmpl, err := template.New("module").Funcs(template.FuncMap{
                "join":       strings.Join,
                "formatTime": formatTime,
        }).Parse(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">g.moduleTemplates[format] = tmpl
        return tmpl, nil</span>
}

// getIndexTemplate returns the index template for the specified format
func (g *DefaultGenerator) getIndexTemplate(format Format) (*template.Template, error) <span class="cov7" title="3">{
        if tmpl, ok := g.indexTemplates[format]; ok </span><span class="cov0" title="0">{
                return tmpl, nil
        }</span>

        <span class="cov7" title="3">var content string
        switch format </span>{
        case FormatMarkdown:<span class="cov1" title="1">
                content = markdownIndexTemplate</span>
        case FormatHTML:<span class="cov1" title="1">
                content = htmlIndexTemplate</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }

        <span class="cov4" title="2">tmpl, err := template.New("index").Funcs(template.FuncMap{
                "join":       strings.Join,
                "formatTime": formatTime,
        }).Parse(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">g.indexTemplates[format] = tmpl
        return tmpl, nil</span>
}

// formatTime formats a time value for display
func formatTime(t time.Time) string <span class="cov10" title="5">{
        return t.Format("2006-01-02 15:04:05")
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package postgres

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/database"
        "github.com/StackCatalyst/common-lib/pkg/metrics"
        "github.com/StackCatalyst/common-lib/pkg/module"
        "github.com/StackCatalyst/common-lib/pkg/module/storage"
        "github.com/jackc/pgx/v5"
)

// Storage implements the storage.Storage interface using PostgreSQL
type Storage struct {
        db      *database.Client
        metrics *metrics.Reporter
}

// Config represents PostgreSQL storage configuration
type Config struct {
        DBConfig      database.Config
        MetricsPrefix string
}

// New creates a new PostgreSQL storage instance
func New(config Config, metrics *metrics.Reporter) (*Storage, error) <span class="cov0" title="0">{
        db, err := database.New(config.DBConfig, metrics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Storage{
                db:      db,
                metrics: metrics,
        }, nil</span>
}

// Store saves a module to PostgreSQL
func (s *Storage) Store(ctx context.Context, module *module.Module) error <span class="cov0" title="0">{
        query := `
                INSERT INTO modules (
                        id, name, provider, version, description, source,
                        variables, outputs, dependencies, tags,
                        created_at, updated_at, metadata, content
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
                )
                ON CONFLICT (id, version) DO UPDATE SET
                        name = EXCLUDED.name,
                        description = EXCLUDED.description,
                        source = EXCLUDED.source,
                        variables = EXCLUDED.variables,
                        outputs = EXCLUDED.outputs,
                        dependencies = EXCLUDED.dependencies,
                        tags = EXCLUDED.tags,
                        updated_at = EXCLUDED.updated_at,
                        metadata = EXCLUDED.metadata,
                        content = EXCLUDED.content
                WHERE NOT modules.locked
        `

        variables, err := json.Marshal(module.Variables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal variables: %w", err)
        }</span>

        <span class="cov0" title="0">outputs, err := json.Marshal(module.Outputs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal outputs: %w", err)
        }</span>

        <span class="cov0" title="0">dependencies, err := json.Marshal(module.Dependencies)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = s.db.Exec(ctx, query,
                module.ID,
                module.Name,
                module.Provider,
                module.Version,
                module.Description,
                module.Source,
                variables,
                outputs,
                dependencies,
                module.Tags,
                module.CreatedAt,
                module.UpdatedAt,
                module.Metadata,
                nil, // content is stored separately
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store module: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get retrieves a module by its ID and version
func (s *Storage) Get(ctx context.Context, id, version string) (*module.Module, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        id, name, provider, version, description, source,
                        variables, outputs, dependencies, tags,
                        created_at, updated_at, metadata
                FROM modules
                WHERE id = $1 AND version = $2
        `

        row := s.db.QueryRow(ctx, query, id, version)
        module := &amp;module.Module{}

        var variables, outputs, dependencies []byte

        err := row.Scan(
                &amp;module.ID,
                &amp;module.Name,
                &amp;module.Provider,
                &amp;module.Version,
                &amp;module.Description,
                &amp;module.Source,
                &amp;variables,
                &amp;outputs,
                &amp;dependencies,
                &amp;module.Tags,
                &amp;module.CreatedAt,
                &amp;module.UpdatedAt,
                &amp;module.Metadata,
        )

        if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("module not found: %s@%s", id, version)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan module: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(variables, &amp;module.Variables); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal variables: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(outputs, &amp;module.Outputs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal outputs: %w", err)
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(dependencies, &amp;module.Dependencies); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">return module, nil</span>
}

// List returns modules matching the given filter
func (s *Storage) List(ctx context.Context, filter storage.Filter) ([]*module.Module, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        id, name, provider, version, description, source,
                        variables, outputs, dependencies, tags,
                        created_at, updated_at, metadata
                FROM modules
                WHERE ($1::text IS NULL OR provider = $1)
                AND ($2::text[] IS NULL OR tags &amp;&amp; $2)
                AND ($3::text IS NULL OR name LIKE $3)
                AND ($4::text IS NULL OR version = $4)
                ORDER BY created_at DESC
                OFFSET $5 LIMIT $6
        `

        rows, err := s.db.Query(ctx, query,
                filter.Provider,
                filter.Tags,
                filter.NamePattern,
                filter.Version,
                filter.Offset,
                filter.Limit,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query modules: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var modules []*module.Module

        for rows.Next() </span><span class="cov0" title="0">{
                module := &amp;module.Module{}
                var variables, outputs, dependencies []byte

                err := rows.Scan(
                        &amp;module.ID,
                        &amp;module.Name,
                        &amp;module.Provider,
                        &amp;module.Version,
                        &amp;module.Description,
                        &amp;module.Source,
                        &amp;variables,
                        &amp;outputs,
                        &amp;dependencies,
                        &amp;module.Tags,
                        &amp;module.CreatedAt,
                        &amp;module.UpdatedAt,
                        &amp;module.Metadata,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan module: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(variables, &amp;module.Variables); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal variables: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(outputs, &amp;module.Outputs); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal outputs: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(dependencies, &amp;module.Dependencies); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal dependencies: %w", err)
                }</span>

                <span class="cov0" title="0">modules = append(modules, module)</span>
        }

        <span class="cov0" title="0">return modules, nil</span>
}

// Delete removes a module from storage
func (s *Storage) Delete(ctx context.Context, id, version string) error <span class="cov0" title="0">{
        query := `DELETE FROM modules WHERE id = $1 AND version = $2 AND NOT locked`
        result, err := s.db.Exec(ctx, query, id, version)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete module: %w", err)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("module not found or locked: %s@%s", id, version)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetVersions returns all versions of a module
func (s *Storage) GetVersions(ctx context.Context, id string) ([]string, error) <span class="cov0" title="0">{
        query := `SELECT version FROM modules WHERE id = $1 ORDER BY version DESC`
        rows, err := s.db.Query(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query versions: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var versions []string
        for rows.Next() </span><span class="cov0" title="0">{
                var version string
                if err := rows.Scan(&amp;version); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan version: %w", err)
                }</span>
                <span class="cov0" title="0">versions = append(versions, version)</span>
        }

        <span class="cov0" title="0">return versions, nil</span>
}

// GetLatestVersion returns the latest version of a module
func (s *Storage) GetLatestVersion(ctx context.Context, id string) (string, error) <span class="cov0" title="0">{
        query := `SELECT version FROM modules WHERE id = $1 ORDER BY version DESC LIMIT 1`
        var version string
        err := s.db.QueryRow(ctx, query, id).Scan(&amp;version)
        if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                return "", fmt.Errorf("module not found: %s", id)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get latest version: %w", err)
        }</span>
        <span class="cov0" title="0">return version, nil</span>
}

// Lock marks a version as immutable
func (s *Storage) Lock(ctx context.Context, id, version string) error <span class="cov0" title="0">{
        query := `UPDATE modules SET locked = true WHERE id = $1 AND version = $2`
        result, err := s.db.Exec(ctx, query, id, version)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to lock module: %w", err)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("module not found: %s@%s", id, version)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetMetadata retrieves module metadata without content
func (s *Storage) GetMetadata(ctx context.Context, id, version string) (*module.Module, error) <span class="cov0" title="0">{
        return s.Get(ctx, id, version)
}</span>

// UpdateMetadata updates module metadata without changing content
func (s *Storage) UpdateMetadata(ctx context.Context, id, version string, metadata map[string]interface{}) error <span class="cov0" title="0">{
        query := `
                UPDATE modules
                SET metadata = $3, updated_at = $4
                WHERE id = $1 AND version = $2 AND NOT locked
        `
        result, err := s.db.Exec(ctx, query, id, version, metadata, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update metadata: %w", err)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("module not found or locked: %s@%s", id, version)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// StoreContent saves module content to storage
func (s *Storage) StoreContent(ctx context.Context, id, version string, content []byte) error <span class="cov0" title="0">{
        query := `
                UPDATE modules
                SET content = $3, updated_at = $4
                WHERE id = $1 AND version = $2 AND NOT locked
        `
        result, err := s.db.Exec(ctx, query, id, version, content, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store content: %w", err)
        }</span>

        <span class="cov0" title="0">if result.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("module not found or locked: %s@%s", id, version)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetContent retrieves module content from storage
func (s *Storage) GetContent(ctx context.Context, id, version string) ([]byte, error) <span class="cov0" title="0">{
        query := `SELECT content FROM modules WHERE id = $1 AND version = $2`
        var content []byte
        err := s.db.QueryRow(ctx, query, id, version).Scan(&amp;content)
        if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("module not found: %s@%s", id, version)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get content: %w", err)
        }</span>
        <span class="cov0" title="0">return content, nil</span>
}

// Exists checks if a module version exists
func (s *Storage) Exists(ctx context.Context, id, version string) (bool, error) <span class="cov0" title="0">{
        query := `SELECT EXISTS(SELECT 1 FROM modules WHERE id = $1 AND version = $2)`
        var exists bool
        err := s.db.QueryRow(ctx, query, id, version).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check existence: %w", err)
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

// GetDependencies returns all modules that depend on the given module
func (s *Storage) GetDependencies(ctx context.Context, id, version string) ([]*module.Module, error) <span class="cov0" title="0">{
        query := `
                SELECT
                        id, name, provider, version, description, source,
                        variables, outputs, dependencies, tags,
                        created_at, updated_at, metadata
                FROM modules
                WHERE dependencies @&gt; $1
        `
        dependency := fmt.Sprintf(`[{"source": "%s", "version": "%s"}]`, id, version)

        rows, err := s.db.Query(ctx, query, dependency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query dependencies: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var modules []*module.Module
        for rows.Next() </span><span class="cov0" title="0">{
                module := &amp;module.Module{}
                var variables, outputs, dependencies []byte

                err := rows.Scan(
                        &amp;module.ID,
                        &amp;module.Name,
                        &amp;module.Provider,
                        &amp;module.Version,
                        &amp;module.Description,
                        &amp;module.Source,
                        &amp;variables,
                        &amp;outputs,
                        &amp;dependencies,
                        &amp;module.Tags,
                        &amp;module.CreatedAt,
                        &amp;module.UpdatedAt,
                        &amp;module.Metadata,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan module: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(variables, &amp;module.Variables); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal variables: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(outputs, &amp;module.Outputs); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal outputs: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(dependencies, &amp;module.Dependencies); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal dependencies: %w", err)
                }</span>

                <span class="cov0" title="0">modules = append(modules, module)</span>
        }

        <span class="cov0" title="0">return modules, nil</span>
}

// Close releases any resources held by the storage
func (s *Storage) Close() error <span class="cov0" title="0">{
        if s.db != nil </span><span class="cov0" title="0">{
                s.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package storage

import (
        "context"
        "io"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/module"
)

// Filter represents search criteria for listing modules
type Filter struct {
        Provider    string   // Cloud provider (aws, azure, gcp)
        Tags        []string // Module tags
        NamePattern string   // Module name pattern (supports wildcards)
        Version     string   // Specific version or constraint
        Offset      int      // Pagination offset
        Limit       int      // Pagination limit
}

// Storage defines the interface for module storage operations
type Storage interface {
        // Store saves a module to the storage
        Store(ctx context.Context, module *module.Module) error

        // Get retrieves a module by its ID and version
        Get(ctx context.Context, id, version string) (*module.Module, error)

        // List returns modules matching the given filter
        List(ctx context.Context, filter Filter) ([]*module.Module, error)

        // Delete removes a module from storage
        Delete(ctx context.Context, id, version string) error

        // GetVersions returns all versions of a module
        GetVersions(ctx context.Context, id string) ([]string, error)

        // GetLatestVersion returns the latest version of a module
        GetLatestVersion(ctx context.Context, id string) (string, error)

        // Lock marks a version as immutable
        Lock(ctx context.Context, id, version string) error

        // GetMetadata retrieves module metadata without content
        GetMetadata(ctx context.Context, id, version string) (*module.Module, error)

        // UpdateMetadata updates module metadata without changing content
        UpdateMetadata(ctx context.Context, id, version string, metadata map[string]interface{}) error

        // StoreContent saves module content to storage
        StoreContent(ctx context.Context, id, version string, content []byte) error

        // GetContent retrieves module content from storage
        GetContent(ctx context.Context, id, version string) ([]byte, error)

        // Exists checks if a module version exists
        Exists(ctx context.Context, id, version string) (bool, error)

        // GetDependencies returns all modules that depend on the given module
        GetDependencies(ctx context.Context, id, version string) ([]*module.Module, error)

        // Close releases any resources held by the storage
        Close() error
}

// Stats represents storage statistics
type Stats struct {
        TotalModules      int       // Total number of modules
        TotalVersions     int       // Total number of module versions
        StorageSize       int64     // Total storage size in bytes
        LastUpdated       time.Time // Last update timestamp
        CacheHitRate      float64   // Cache hit rate
        CacheMissRate     float64   // Cache miss rate
        AvgResponseTime   float64   // Average response time in milliseconds
        ErrorRate         float64   // Error rate percentage
        ActiveConnections int       // Number of active connections
}

// Backend represents a storage backend for modules
type Backend interface {
        // Store stores a module in the backend
        Store(ctx context.Context, mod *module.Module, content io.Reader) error

        // Get retrieves a module from the backend
        Get(ctx context.Context, id string) (*module.Module, io.ReadCloser, error)

        // List lists modules matching the filter
        List(ctx context.Context, filter module.Filter) ([]*module.Module, error)

        // Delete deletes a module from the backend
        Delete(ctx context.Context, id string) error

        // GetContent retrieves the module content
        GetContent(ctx context.Context, id string) (io.ReadCloser, error)

        // StoreContent stores the module content
        StoreContent(ctx context.Context, id string, content io.Reader) error

        // DeleteContent deletes the module content
        DeleteContent(ctx context.Context, id string) error

        // Close closes the storage backend
        Close() error
}

// Config holds the storage backend configuration
type Config struct {
        // Type is the storage backend type (e.g., postgres, s3)
        Type string `json:"type" yaml:"type"`

        // PostgreSQL configuration
        PostgreSQL *PostgreSQLConfig `json:"postgresql,omitempty" yaml:"postgresql,omitempty"`

        // S3 configuration
        S3 *S3Config `json:"s3,omitempty" yaml:"s3,omitempty"`

        // Cache configuration
        Cache *CacheConfig `json:"cache,omitempty" yaml:"cache,omitempty"`
}

// PostgreSQLConfig holds PostgreSQL-specific configuration
type PostgreSQLConfig struct {
        // Host is the database server hostname
        Host string `json:"host" yaml:"host"`
        // Port is the database server port
        Port int `json:"port" yaml:"port"`
        // Database is the name of the database to connect to
        Database string `json:"database" yaml:"database"`
        // User is the database user
        User string `json:"user" yaml:"user"`
        // Password is the database password
        Password string `json:"password" yaml:"password"`
        // SSLMode is the SSL mode to use for the connection
        SSLMode string `json:"ssl_mode" yaml:"ssl_mode"`
}

// S3Config holds S3-specific configuration
type S3Config struct {
        // Bucket is the S3 bucket name
        Bucket string `json:"bucket" yaml:"bucket"`
        // Region is the AWS region
        Region string `json:"region" yaml:"region"`
        // Endpoint is the S3-compatible endpoint (optional)
        Endpoint string `json:"endpoint,omitempty" yaml:"endpoint,omitempty"`
        // AccessKey is the AWS access key
        AccessKey string `json:"access_key" yaml:"access_key"`
        // SecretKey is the AWS secret key
        SecretKey string `json:"secret_key" yaml:"secret_key"`
}

// CacheConfig holds cache configuration
type CacheConfig struct {
        // Enabled indicates if caching is enabled
        Enabled bool `json:"enabled" yaml:"enabled"`
        // TTL is the cache time-to-live
        TTL string `json:"ttl" yaml:"ttl"`
        // MaxSize is the maximum cache size in bytes
        MaxSize int64 `json:"max_size" yaml:"max_size"`
}

// Error represents a storage error
type Error struct {
        // Code is the error code
        Code string
        // Message is the error message
        Message string
        // Err is the underlying error
        Err error
}

// Error returns the error message
func (e *Error) Error() string <span class="cov10" title="2">{
        if e.Err != nil </span><span class="cov1" title="1">{
                return e.Message + ": " + e.Err.Error()
        }</span>
        <span class="cov1" title="1">return e.Message</span>
}

// Unwrap returns the underlying error
func (e *Error) Unwrap() error <span class="cov10" title="2">{
        return e.Err
}</span>

// Error codes
const (
        ErrNotFound      = "NOT_FOUND"
        ErrAlreadyExists = "ALREADY_EXISTS"
        ErrInvalidInput  = "INVALID_INPUT"
        ErrInternal      = "INTERNAL"
)
</pre>
		
		<pre class="file" id="file29" style="display: none">package testing

import (
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"
)

// AssertionResult represents the result of an assertion evaluation
type AssertionResult struct {
        // Assertion is the original assertion string
        Assertion string
        // Success indicates if the assertion passed
        Success bool
        // Message contains details about the assertion result
        Message string
}

// AssertionContext contains data needed for assertion evaluation
type AssertionContext struct {
        // Variables contains the current variable values
        Variables map[string]interface{}
        // Outputs contains the current output values
        Outputs map[string]interface{}
        // Resources contains the created resources
        Resources []*Resource
}

// EvaluateAssertion evaluates a single assertion
func EvaluateAssertion(assertion string, ctx *AssertionContext) *AssertionResult <span class="cov10" title="18">{
        result := &amp;AssertionResult{
                Assertion: assertion,
        }

        // Parse assertion components
        parts := strings.Fields(assertion)
        if len(parts) &lt; 3 </span><span class="cov1" title="1">{
                result.Success = false
                result.Message = "invalid assertion format: must contain at least 3 parts"
                return result
        }</span>

        // Get value based on reference type
        <span class="cov9" title="17">var actualValue interface{}
        var expectedValue string
        switch parts[0] </span>{
        case "variable":<span class="cov8" title="10">
                actualValue = ctx.Variables[parts[1]]
                if len(parts) &gt; 3 &amp;&amp; parts[2] != "exists" </span><span class="cov7" title="9">{
                        expectedValue = parts[3]
                }</span>
        case "output":<span class="cov5" title="4">
                actualValue = ctx.Outputs[parts[1]]
                if len(parts) &gt; 3 </span><span class="cov5" title="4">{
                        expectedValue = parts[3]
                }</span>
        case "resource":<span class="cov3" title="2">
                if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Message = "invalid resource assertion format: must contain at least 4 parts"
                        return result
                }</span>
                <span class="cov3" title="2">actualValue = findResourceProperty(ctx.Resources, parts[1], parts[2])
                if len(parts) &gt; 4 </span><span class="cov3" title="2">{
                        expectedValue = parts[4]
                }</span>
                <span class="cov3" title="2">parts = []string{parts[0], parts[1], parts[3]} // Adjust parts for condition evaluation
                if expectedValue != "" </span><span class="cov3" title="2">{
                        parts = append(parts, expectedValue)
                }</span>
        default:<span class="cov1" title="1">
                result.Success = false
                result.Message = fmt.Sprintf("unknown reference type: %s", parts[0])
                return result</span>
        }

        // Evaluate condition
        <span class="cov9" title="16">switch parts[2] </span>{
        case "equals", "=":<span class="cov8" title="11">
                if expectedValue == "" </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Message = "missing expected value for equals condition"
                        return result
                }</span>
                <span class="cov8" title="11">result.Success = evaluateEquals(actualValue, expectedValue)
                result.Message = fmt.Sprintf("expected %v to equal %v", actualValue, expectedValue)</span>

        case "contains":<span class="cov1" title="1">
                if expectedValue == "" </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Message = "missing expected value for contains condition"
                        return result
                }</span>
                <span class="cov1" title="1">result.Success = evaluateContains(actualValue, expectedValue)
                result.Message = fmt.Sprintf("expected %v to contain %v", actualValue, expectedValue)</span>

        case "matches":<span class="cov1" title="1">
                if expectedValue == "" </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Message = "missing expected value for matches condition"
                        return result
                }</span>
                <span class="cov1" title="1">result.Success = evaluateMatches(actualValue, expectedValue)
                result.Message = fmt.Sprintf("expected %v to match pattern %v", actualValue, expectedValue)</span>

        case "exists":<span class="cov1" title="1">
                result.Success = actualValue != nil
                result.Message = fmt.Sprintf("expected %s to exist", parts[1])</span>

        case "type":<span class="cov1" title="1">
                if expectedValue == "" </span><span class="cov0" title="0">{
                        result.Success = false
                        result.Message = "missing expected value for type condition"
                        return result
                }</span>
                <span class="cov1" title="1">result.Success = evaluateType(actualValue, expectedValue)
                result.Message = fmt.Sprintf("expected %v to be of type %s", actualValue, expectedValue)</span>

        default:<span class="cov1" title="1">
                result.Success = false
                result.Message = fmt.Sprintf("unknown condition: %s", parts[2])</span>
        }

        <span class="cov9" title="16">return result</span>
}

// findResourceProperty finds a property value in a list of resources
func findResourceProperty(resources []*Resource, id, property string) interface{} <span class="cov7" title="8">{
        for _, r := range resources </span><span class="cov7" title="8">{
                if r.ID == id </span><span class="cov7" title="7">{
                        if strings.Contains(property, ".") </span><span class="cov5" title="4">{
                                // Handle nested properties
                                parts := strings.Split(property, ".")
                                var value interface{} = r.Properties
                                for _, part := range parts </span><span class="cov7" title="9">{
                                        if m, ok := value.(map[string]interface{}); ok </span><span class="cov7" title="9">{
                                                value = m[part]
                                                if value == nil </span><span class="cov1" title="1">{
                                                        return nil
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                return nil
                                        }</span>
                                }
                                <span class="cov4" title="3">return value</span>
                        }
                        <span class="cov4" title="3">return r.Properties[property]</span>
                }
        }
        <span class="cov1" title="1">return nil</span>
}

// evaluateEquals compares two values for equality
func evaluateEquals(actual interface{}, expected string) bool <span class="cov8" title="11">{
        // Handle different types
        switch v := actual.(type) </span>{
        case string:<span class="cov6" title="5">
                return v == expected</span>
        case int:<span class="cov4" title="3">
                if n, err := strconv.Atoi(expected); err == nil </span><span class="cov4" title="3">{
                        return v == n
                }</span>
        case float64:<span class="cov0" title="0">
                if n, err := strconv.ParseFloat(expected, 64); err == nil </span><span class="cov0" title="0">{
                        return v == n
                }</span>
        case bool:<span class="cov3" title="2">
                if b, err := strconv.ParseBool(expected); err == nil </span><span class="cov3" title="2">{
                        return v == b
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// evaluateContains checks if a value contains another value
func evaluateContains(actual interface{}, expected string) bool <span class="cov1" title="1">{
        switch v := actual.(type) </span>{
        case string:<span class="cov0" title="0">
                return strings.Contains(v, expected)</span>
        case []interface{}:<span class="cov1" title="1">
                for _, item := range v </span><span class="cov3" title="2">{
                        if fmt.Sprintf("%v", item) == expected </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
        case map[string]interface{}:<span class="cov0" title="0">
                _, exists := v[expected]
                return exists</span>
        }
        <span class="cov0" title="0">return false</span>
}

// evaluateMatches checks if a value matches a pattern
func evaluateMatches(actual interface{}, pattern string) bool <span class="cov1" title="1">{
        str := fmt.Sprintf("%v", actual)
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">return re.MatchString(str)</span>
}

// evaluateType checks if a value is of the expected type
func evaluateType(actual interface{}, expectedType string) bool <span class="cov1" title="1">{
        if actual == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">actualType := reflect.TypeOf(actual).String()
        return strings.EqualFold(actualType, expectedType)</span>
}

// CompareValues compares two values with type conversion
func CompareValues(actual, expected interface{}) (bool, string) <span class="cov8" title="12">{
        if actual == nil &amp;&amp; expected == nil </span><span class="cov1" title="1">{
                return true, ""
        }</span>
        <span class="cov8" title="11">if actual == nil || expected == nil </span><span class="cov1" title="1">{
                return false, fmt.Sprintf("expected %v but got %v", expected, actual)
        }</span>

        // Convert expected value to actual type if possible
        <span class="cov8" title="10">actualValue := reflect.ValueOf(actual)
        expectedValue := reflect.ValueOf(expected)

        switch actualValue.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov6" title="5">
                if expectedValue.Kind() == reflect.String </span><span class="cov3" title="2">{
                        if n, err := strconv.ParseInt(expectedValue.String(), 10, 64); err == nil </span><span class="cov1" title="1">{
                                return actualValue.Int() == n, ""
                        }</span>
                }
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                if expectedValue.Kind() == reflect.String </span><span class="cov0" title="0">{
                        if n, err := strconv.ParseFloat(expectedValue.String(), 64); err == nil </span><span class="cov0" title="0">{
                                return actualValue.Float() == n, ""
                        }</span>
                }
        case reflect.Bool:<span class="cov1" title="1">
                if expectedValue.Kind() == reflect.String </span><span class="cov1" title="1">{
                        if b, err := strconv.ParseBool(expectedValue.String()); err == nil </span><span class="cov1" title="1">{
                                return actualValue.Bool() == b, ""
                        }</span>
                }
        case reflect.String:<span class="cov3" title="2">
                return actualValue.String() == fmt.Sprintf("%v", expected), ""</span>
        case reflect.Slice, reflect.Array:<span class="cov1" title="1">
                if expectedValue.Kind() == reflect.Slice || expectedValue.Kind() == reflect.Array </span><span class="cov1" title="1">{
                        if actualValue.Len() != expectedValue.Len() </span><span class="cov0" title="0">{
                                return false, "length mismatch"
                        }</span>
                        <span class="cov1" title="1">for i := 0; i &lt; actualValue.Len(); i++ </span><span class="cov4" title="3">{
                                if eq, _ := CompareValues(actualValue.Index(i).Interface(), expectedValue.Index(i).Interface()); !eq </span><span class="cov0" title="0">{
                                        return false, fmt.Sprintf("mismatch at index %d", i)
                                }</span>
                        }
                        <span class="cov1" title="1">return true, ""</span>
                }
        case reflect.Map:<span class="cov1" title="1">
                if expectedValue.Kind() == reflect.Map </span><span class="cov1" title="1">{
                        if actualValue.Len() != expectedValue.Len() </span><span class="cov0" title="0">{
                                return false, "length mismatch"
                        }</span>
                        <span class="cov1" title="1">for _, key := range expectedValue.MapKeys() </span><span class="cov1" title="1">{
                                actualMapValue := actualValue.MapIndex(key)
                                if !actualMapValue.IsValid() </span><span class="cov0" title="0">{
                                        return false, fmt.Sprintf("missing key %v", key)
                                }</span>
                                <span class="cov1" title="1">if eq, _ := CompareValues(actualMapValue.Interface(), expectedValue.MapIndex(key).Interface()); !eq </span><span class="cov0" title="0">{
                                        return false, fmt.Sprintf("mismatch at key %v", key)
                                }</span>
                        }
                        <span class="cov1" title="1">return true, ""</span>
                }
        }

        // If types are different and no conversion was possible
        <span class="cov5" title="4">if actualValue.Type() != expectedValue.Type() </span><span class="cov1" title="1">{
                return false, fmt.Sprintf("type mismatch: expected %T but got %T", expected, actual)
        }</span>

        // Direct comparison for same types
        <span class="cov4" title="3">return reflect.DeepEqual(actual, expected), ""</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package testing

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// MockProvider is a mock implementation of Provider for testing
type MockProvider struct {
        mu        sync.RWMutex
        resources map[string]*Resource
}

// NewMockProvider creates a new mock provider
func NewMockProvider() Provider <span class="cov7" title="3">{
        return &amp;MockProvider{
                resources: make(map[string]*Resource),
        }
}</span>

// CreateResource simulates creating a cloud resource
func (p *MockProvider) CreateResource(ctx context.Context, resource *Resource) error <span class="cov1" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if resource.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("resource ID is required")
        }</span>

        <span class="cov1" title="1">if _, exists := p.resources[resource.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("resource %s already exists", resource.ID)
        }</span>

        <span class="cov1" title="1">if err := p.ValidateResource(resource); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">resource.CreatedAt = time.Now()
        p.resources[resource.ID] = resource

        // Simulate API delay
        time.Sleep(100 * time.Millisecond)

        return nil</span>
}

// DeleteResource simulates deleting a cloud resource
func (p *MockProvider) DeleteResource(ctx context.Context, resource *Resource) error <span class="cov1" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        if resource.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("resource ID is required")
        }</span>

        <span class="cov1" title="1">if _, exists := p.resources[resource.ID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("resource %s not found", resource.ID)
        }</span>

        <span class="cov1" title="1">delete(p.resources, resource.ID)

        // Simulate API delay
        time.Sleep(100 * time.Millisecond)

        return nil</span>
}

// GetResource simulates getting information about a cloud resource
func (p *MockProvider) GetResource(ctx context.Context, id string) (*Resource, error) <span class="cov4" title="2">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        if id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resource ID is required")
        }</span>

        <span class="cov4" title="2">resource, exists := p.resources[id]
        if !exists </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("resource %s not found", id)
        }</span>

        // Simulate API delay
        <span class="cov1" title="1">time.Sleep(50 * time.Millisecond)

        return resource, nil</span>
}

// ListResources simulates listing cloud resources
func (p *MockProvider) ListResources(ctx context.Context, filter map[string]string) ([]*Resource, error) <span class="cov1" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        var resources []*Resource

        for _, resource := range p.resources </span><span class="cov1" title="1">{
                matches := true
                for k, v := range filter </span><span class="cov1" title="1">{
                        if tagValue, ok := resource.Tags[k]; !ok || tagValue != v </span><span class="cov0" title="0">{
                                matches = false
                                break</span>
                        }
                }
                <span class="cov1" title="1">if matches </span><span class="cov1" title="1">{
                        resources = append(resources, resource)
                }</span>
        }

        // Simulate API delay
        <span class="cov1" title="1">time.Sleep(50 * time.Millisecond)

        return resources, nil</span>
}

// ValidateResource validates a resource definition
func (p *MockProvider) ValidateResource(resource *Resource) error <span class="cov10" title="5">{
        if resource.Type == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("resource type is required")
        }</span>

        <span class="cov8" title="4">if resource.Provider == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("resource provider is required")
        }</span>

        <span class="cov7" title="3">if resource.Region == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("resource region is required")
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package testing

import (
        "context"
        "fmt"
        "time"

        "github.com/StackCatalyst/common-lib/pkg/module"
)

// Result represents the result of a test run
type Result struct {
        // ModuleID is the ID of the tested module
        ModuleID string
        // Version is the version of the tested module
        Version string
        // Status is the overall test status
        Status Status
        // StartTime is when the test started
        StartTime time.Time
        // EndTime is when the test completed
        EndTime time.Time
        // Duration is how long the test took
        Duration time.Duration
        // Tests contains individual test results
        Tests []*TestCase
        // Resources contains information about resources created during testing
        Resources []*Resource
        // Logs contains test execution logs
        Logs []string
        // Error contains any error that occurred during testing
        Error error
}

// Status represents the test status
type Status string

const (
        // StatusPassed indicates all tests passed
        StatusPassed Status = "passed"
        // StatusFailed indicates one or more tests failed
        StatusFailed Status = "failed"
        // StatusError indicates an error occurred during testing
        StatusError Status = "error"
        // StatusSkipped indicates testing was skipped
        StatusSkipped Status = "skipped"
)

// TestCase represents an individual test case
type TestCase struct {
        // Name is the test case name
        Name string
        // Description describes what the test verifies
        Description string
        // Status is the test case status
        Status Status
        // StartTime is when the test case started
        StartTime time.Time
        // EndTime is when the test case completed
        EndTime time.Time
        // Duration is how long the test case took
        Duration time.Duration
        // Error contains any error that occurred
        Error error
        // Logs contains test case execution logs
        Logs []string
}

// Resource represents a cloud resource created during testing
type Resource struct {
        // ID is the resource identifier
        ID string
        // Type is the resource type
        Type string
        // Provider is the cloud provider
        Provider string
        // Region is the resource region
        Region string
        // Tags are resource tags
        Tags map[string]string
        // Properties contains resource-specific properties
        Properties map[string]interface{}
        // CreatedAt is when the resource was created
        CreatedAt time.Time
        // Cost is the estimated resource cost
        Cost float64
}

// Config represents test configuration
type Config struct {
        // Provider is the cloud provider to test against
        Provider string
        // Region is the region to create resources in
        Region string
        // Credentials contains provider credentials
        Credentials map[string]string
        // Variables contains module input variables
        Variables map[string]interface{}
        // Timeout is the maximum test duration
        Timeout time.Duration
        // Parallel is whether to run tests in parallel
        Parallel bool
        // KeepResources determines if resources should be preserved after testing
        KeepResources bool
        // Tags are tags to apply to created resources
        Tags map[string]string
}

// Runner executes module tests
type Runner interface {
        // Run executes tests for a module
        Run(ctx context.Context, module *module.Module, config *Config) (*Result, error)

        // Mock returns a mock provider for testing
        Mock(provider string) Provider

        // Cleanup removes any resources created during testing
        Cleanup(ctx context.Context, result *Result) error

        // Report generates a test report
        Report(result *Result) ([]byte, error)
}

// Provider represents a cloud provider
type Provider interface {
        // CreateResource creates a cloud resource
        CreateResource(ctx context.Context, resource *Resource) error

        // DeleteResource deletes a cloud resource
        DeleteResource(ctx context.Context, resource *Resource) error

        // GetResource gets information about a cloud resource
        GetResource(ctx context.Context, id string) (*Resource, error)

        // ListResources lists cloud resources
        ListResources(ctx context.Context, filter map[string]string) ([]*Resource, error)

        // ValidateResource validates a resource definition
        ValidateResource(resource *Resource) error
}

// DefaultRunner is the default implementation of Runner
type DefaultRunner struct {
        providers map[string]Provider
}

// NewRunner creates a new test runner
func NewRunner() Runner <span class="cov1" title="1">{
        return &amp;DefaultRunner{
                providers: make(map[string]Provider),
        }
}</span>

// Run executes tests for a module
func (r *DefaultRunner) Run(ctx context.Context, module *module.Module, config *Config) (*Result, error) <span class="cov1" title="1">{
        result := &amp;Result{
                ModuleID:  module.ID,
                Version:   module.Version,
                StartTime: time.Now(),
        }

        // Get or create provider
        provider, ok := r.providers[config.Provider]
        if !ok </span><span class="cov1" title="1">{
                provider = r.Mock(config.Provider)
                r.providers[config.Provider] = provider
        }</span>

        // Run test cases
        <span class="cov1" title="1">for _, test := range module.Tests </span><span class="cov5" title="2">{
                caseResult := r.runTestCase(ctx, test, module, config, provider)
                result.Tests = append(result.Tests, caseResult)

                // Update overall status
                if caseResult.Status == StatusError </span><span class="cov0" title="0">{
                        result.Status = StatusError
                        break</span>
                } else<span class="cov5" title="2"> if caseResult.Status == StatusFailed &amp;&amp; result.Status != StatusError </span><span class="cov0" title="0">{
                        result.Status = StatusFailed
                }</span> else<span class="cov5" title="2"> if result.Status == "" </span><span class="cov1" title="1">{
                        result.Status = StatusPassed
                }</span>
        }

        <span class="cov1" title="1">result.EndTime = time.Now()
        result.Duration = result.EndTime.Sub(result.StartTime)

        return result, nil</span>
}

// Mock returns a mock provider for testing
func (r *DefaultRunner) Mock(provider string) Provider <span class="cov1" title="1">{
        return NewMockProvider()
}</span>

// Cleanup removes any resources created during testing
func (r *DefaultRunner) Cleanup(ctx context.Context, result *Result) error <span class="cov1" title="1">{
        for _, resource := range result.Resources </span><span class="cov0" title="0">{
                if provider, ok := r.providers[resource.Provider]; ok </span><span class="cov0" title="0">{
                        if err := provider.DeleteResource(ctx, resource); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov1" title="1">return nil</span>
}

// Report generates a test report
func (r *DefaultRunner) Report(result *Result) ([]byte, error) <span class="cov0" title="0">{
        // TODO: Implement report generation
        return nil, nil
}</span>

// runTestCase executes a single test case
func (r *DefaultRunner) runTestCase(
        ctx context.Context,
        test *module.Test,
        module *module.Module,
        config *Config,
        provider Provider,
) *TestCase <span class="cov5" title="2">{
        now := time.Now()
        testCase := &amp;TestCase{
                Name:        test.Name,
                Description: test.Description,
                StartTime:   now,
        }

        // Check if test should be skipped
        if test.Skip </span><span class="cov1" title="1">{
                testCase.Status = StatusSkipped
                testCase.Logs = append(testCase.Logs, fmt.Sprintf("Test skipped: %s", test.SkipReason))
                testCase.EndTime = time.Now()
                testCase.Duration = testCase.EndTime.Sub(testCase.StartTime)
                return testCase
        }</span>

        // Create test context with timeout
        <span class="cov1" title="1">timeout := test.Timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = config.Timeout
        }</span>
        <span class="cov1" title="1">if timeout &gt; 0 </span><span class="cov1" title="1">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, timeout)
                defer cancel()
        }</span>

        // Run setup steps
        <span class="cov1" title="1">for _, step := range test.Setup </span><span class="cov5" title="2">{
                testCase.Logs = append(testCase.Logs, fmt.Sprintf("Setup: %s", step))
        }</span>

        // Create assertion context
        <span class="cov1" title="1">assertCtx := &amp;AssertionContext{
                Variables: test.Variables,
                Outputs:   test.ExpectedOutputs,
                Resources: make([]*Resource, 0),
        }

        // Verify assertions
        testCase.Status = StatusPassed
        for _, assertion := range test.Assertions </span><span class="cov10" title="4">{
                result := EvaluateAssertion(assertion, assertCtx)
                if !result.Success </span><span class="cov0" title="0">{
                        testCase.Status = StatusFailed
                        testCase.Error = fmt.Errorf("assertion failed: %s", result.Message)
                        break</span>
                }
                <span class="cov10" title="4">testCase.Logs = append(testCase.Logs, fmt.Sprintf("Assertion passed: %s", assertion))</span>
        }

        // Run teardown steps
        <span class="cov1" title="1">for _, step := range test.Teardown </span><span class="cov5" title="2">{
                testCase.Logs = append(testCase.Logs, fmt.Sprintf("Teardown: %s", step))
        }</span>

        <span class="cov1" title="1">testCase.EndTime = time.Now()
        testCase.Duration = testCase.EndTime.Sub(testCase.StartTime)
        return testCase</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package validation

import (
        "context"
        "fmt"
        "strings"

        "github.com/StackCatalyst/common-lib/pkg/module"
        "github.com/StackCatalyst/common-lib/pkg/module/version"
)

// DependencyValidator defines the interface for dependency validation
type DependencyValidator interface {
        Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error)
}

// DefaultDependencyValidator implements DependencyValidator
type DefaultDependencyValidator struct {
        versionManager version.Manager
}

// NewDependencyValidator creates a new DefaultDependencyValidator instance
func NewDependencyValidator() DependencyValidator <span class="cov3" title="2">{
        return &amp;DefaultDependencyValidator{
                versionManager: version.NewManager(),
        }
}</span>

// Validate performs dependency validation on a module
func (v *DefaultDependencyValidator) Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error) <span class="cov8" title="7">{
        result := &amp;ValidationResult{
                Valid:  true,
                Errors: make([]ValidationError, 0),
        }

        // Validate module version format
        if !v.versionManager.IsValid(mod.Version) </span><span class="cov3" title="2">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   "version",
                        Message: fmt.Sprintf("invalid module version format: %s", mod.Version),
                })
        }</span>

        // Validate dependencies
        <span class="cov8" title="7">seen := make(map[string]bool)
        for i, dep := range mod.Dependencies </span><span class="cov10" title="9">{
                // Validate required fields
                if dep.Name == "" </span><span class="cov3" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("dependencies[%d].name", i),
                                Message: "dependency name is required",
                        })
                }</span> else<span class="cov8" title="7"> {
                        // Check for circular dependencies
                        if dep.Name == mod.Name </span><span class="cov1" title="1">{
                                result.Valid = false
                                result.Errors = append(result.Errors, ValidationError{
                                        Field:   fmt.Sprintf("dependencies[%d].name", i),
                                        Message: "circular dependency detected: module cannot depend on itself",
                                })
                        }</span>

                        // Check for duplicate dependencies
                        <span class="cov8" title="7">if seen[dep.Name] </span><span class="cov1" title="1">{
                                result.Valid = false
                                result.Errors = append(result.Errors, ValidationError{
                                        Field:   fmt.Sprintf("dependencies[%d].name", i),
                                        Message: fmt.Sprintf("duplicate dependency: %s", dep.Name),
                                })
                        }</span>
                        <span class="cov8" title="7">seen[dep.Name] = true</span>
                }

                <span class="cov10" title="9">if dep.Source == "" </span><span class="cov3" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("dependencies[%d].source", i),
                                Message: "dependency source is required",
                        })
                }</span>

                // Validate version constraint format
                <span class="cov10" title="9">if dep.Version != "" </span><span class="cov10" title="9">{
                        // Check if it's a constraint (starts with ~, ^, &gt;=, &gt;, &lt;=, &lt;, or =)
                        isConstraint := strings.ContainsAny(dep.Version[0:1], "~^&gt;&lt;")
                        if !isConstraint &amp;&amp; !strings.HasPrefix(dep.Version, "=") </span><span class="cov3" title="2">{
                                // If it's not a constraint, it should be a valid version
                                if !v.versionManager.IsValid(dep.Version) </span><span class="cov3" title="2">{
                                        result.Valid = false
                                        result.Errors = append(result.Errors, ValidationError{
                                                Field:   fmt.Sprintf("dependencies[%d].version", i),
                                                Message: fmt.Sprintf("invalid version format: %s", dep.Version),
                                        })
                                }</span>
                        } else<span class="cov8" title="7"> {
                                // Try to parse the constraint
                                if _, err := v.versionManager.IsSatisfied("1.0.0", dep.Version); err != nil </span><span class="cov0" title="0">{
                                        result.Valid = false
                                        result.Errors = append(result.Errors, ValidationError{
                                                Field:   fmt.Sprintf("dependencies[%d].version", i),
                                                Message: fmt.Sprintf("invalid version constraint format: %v", err),
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="7">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package validation

import (
        "context"
        "fmt"
        "regexp"

        "github.com/StackCatalyst/common-lib/pkg/module"
)

// ResourceValidator defines the interface for resource validation
type ResourceValidator interface {
        Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error)
}

// DefaultResourceValidator implements ResourceValidator
type DefaultResourceValidator struct{}

// NewResourceValidator creates a new DefaultResourceValidator instance
func NewResourceValidator() ResourceValidator <span class="cov4" title="2">{
        return &amp;DefaultResourceValidator{}
}</span>

// Validate performs resource validation on a module
func (v *DefaultResourceValidator) Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error) <span class="cov10" title="8">{
        result := &amp;ValidationResult{
                Valid:  true,
                Errors: make([]ValidationError, 0),
        }

        // Validate resources
        for i, res := range mod.Resources </span><span class="cov10" title="8">{
                // Validate required fields
                if res.Type == "" </span><span class="cov4" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("resources[%d].type", i),
                                Message: "resource type is required",
                        })
                }</span>

                <span class="cov10" title="8">if res.Provider == "" </span><span class="cov4" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("resources[%d].provider", i),
                                Message: "resource provider is required",
                        })
                }</span>

                // Validate properties
                <span class="cov10" title="8">if res.Properties != nil </span><span class="cov8" title="6">{
                        for propName, prop := range res.Properties </span><span class="cov9" title="7">{
                                if prop.Type == "" </span><span class="cov4" title="2">{
                                        result.Valid = false
                                        result.Errors = append(result.Errors, ValidationError{
                                                Field:   fmt.Sprintf("resources[%d].properties.%s.type", i, propName),
                                                Message: "property type is required",
                                        })
                                }</span>

                                // Validate property type
                                <span class="cov9" title="7">validTypes := map[string]bool{
                                        "string": true,
                                        "number": true,
                                        "bool":   true,
                                        "list":   true,
                                        "map":    true,
                                        "object": true,
                                }
                                if !validTypes[prop.Type] </span><span class="cov5" title="3">{
                                        result.Valid = false
                                        result.Errors = append(result.Errors, ValidationError{
                                                Field:   fmt.Sprintf("resources[%d].properties.%s.type", i, propName),
                                                Message: "invalid property type",
                                        })
                                }</span>

                                // Validate required properties have descriptions
                                <span class="cov9" title="7">if prop.Required &amp;&amp; prop.Description == "" </span><span class="cov5" title="3">{
                                        result.Valid = false
                                        result.Errors = append(result.Errors, ValidationError{
                                                Field:   fmt.Sprintf("resources[%d].properties.%s.description", i, propName),
                                                Message: "description is required for required properties",
                                        })
                                }</span>
                        }
                }

                // Validate resource naming convention (alphanumeric with underscores)
                <span class="cov10" title="8">if matched, _ := regexp.MatchString("^[a-zA-Z][a-zA-Z0-9_]*$", res.Type); !matched </span><span class="cov5" title="3">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("resources[%d].type", i),
                                Message: "resource type must start with a letter and contain only alphanumeric characters and underscores",
                        })
                }</span>

                // Validate provider naming convention (alphanumeric with underscores)
                <span class="cov10" title="8">if matched, _ := regexp.MatchString("^[a-zA-Z][a-zA-Z0-9_]*$", res.Provider); !matched </span><span class="cov5" title="3">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("resources[%d].provider", i),
                                Message: "provider must start with a letter and contain only alphanumeric characters and underscores",
                        })
                }</span>
        }

        <span class="cov10" title="8">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package validation

import (
        "context"
        "fmt"
        "regexp"

        "github.com/StackCatalyst/common-lib/pkg/module"
)

// SchemaValidator defines the interface for schema validation
type SchemaValidator interface {
        Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error)
}

// DefaultSchemaValidator implements SchemaValidator
type DefaultSchemaValidator struct{}

// NewSchemaValidator creates a new DefaultSchemaValidator instance
func NewSchemaValidator() SchemaValidator <span class="cov4" title="2">{
        return &amp;DefaultSchemaValidator{}
}</span>

// Validate performs schema validation on a module
func (v *DefaultSchemaValidator) Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error) <span class="cov10" title="7">{
        result := &amp;ValidationResult{
                Valid:  true,
                Errors: make([]ValidationError, 0),
        }

        // Validate required fields
        if mod.ID == "" </span><span class="cov4" title="2">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   "id",
                        Message: "module ID is required",
                })
        }</span>

        <span class="cov10" title="7">if mod.Name == "" </span><span class="cov4" title="2">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   "name",
                        Message: "module name is required",
                })
        }</span>

        <span class="cov10" title="7">if mod.Version == "" </span><span class="cov4" title="2">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   "version",
                        Message: "module version is required",
                })
        }</span>

        // Validate ID format (alphanumeric with hyphens)
        <span class="cov10" title="7">if matched, _ := regexp.MatchString("^[a-zA-Z0-9-]+$", mod.ID); !matched &amp;&amp; mod.ID != "" </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   "id",
                        Message: "module ID must contain only alphanumeric characters and hyphens",
                })
        }</span>

        // Validate variables
        <span class="cov10" title="7">for i, v := range mod.Variables </span><span class="cov9" title="6">{
                if v.Name == "" </span><span class="cov4" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("variables[%d].name", i),
                                Message: "variable name is required",
                        })
                }</span>

                <span class="cov9" title="6">if v.Type == "" </span><span class="cov0" title="0">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("variables[%d].type", i),
                                Message: "variable type is required",
                        })
                }</span>

                // Validate variable type
                <span class="cov9" title="6">validTypes := map[string]bool{
                        "string": true,
                        "number": true,
                        "bool":   true,
                        "list":   true,
                        "map":    true,
                        "object": true,
                }
                if !validTypes[v.Type] </span><span class="cov4" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("variables[%d].type", i),
                                Message: "invalid variable type",
                        })
                }</span>

                // Validate validation rules if present
                <span class="cov9" title="6">if v.Validation != nil </span><span class="cov4" title="2">{
                        if v.Validation.Pattern != "" </span><span class="cov4" title="2">{
                                if _, err := regexp.Compile(v.Validation.Pattern); err != nil </span><span class="cov1" title="1">{
                                        result.Valid = false
                                        result.Errors = append(result.Errors, ValidationError{
                                                Field:   fmt.Sprintf("variables[%d].validation.pattern", i),
                                                Message: "invalid regex pattern",
                                        })
                                }</span>
                        }
                }
        }

        // Validate resources
        <span class="cov10" title="7">for i, r := range mod.Resources </span><span class="cov7" title="4">{
                if r.Type == "" </span><span class="cov4" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("resources[%d].type", i),
                                Message: "resource type is required",
                        })
                }</span>

                <span class="cov7" title="4">if r.Provider == "" </span><span class="cov4" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("resources[%d].provider", i),
                                Message: "resource provider is required",
                        })
                }</span>
        }

        // Validate tests
        <span class="cov10" title="7">for i, t := range mod.Tests </span><span class="cov4" title="2">{
                if t.Name == "" </span><span class="cov1" title="1">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("tests[%d].name", i),
                                Message: "test name is required",
                        })
                }</span>

                <span class="cov4" title="2">if t.Skip &amp;&amp; t.SkipReason == "" </span><span class="cov1" title="1">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   fmt.Sprintf("tests[%d].skip_reason", i),
                                Message: "skip reason is required when test is skipped",
                        })
                }</span>
        }

        <span class="cov10" title="7">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package validation

import (
        "context"

        "github.com/StackCatalyst/common-lib/pkg/module"
)

// ValidationError represents a validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// ValidationResult represents the result of a validation operation
type ValidationResult struct {
        Valid  bool              `json:"valid"`
        Errors []ValidationError `json:"errors,omitempty"`
}

// Validator defines the interface for module validation
type Validator interface {
        // Validate performs validation on a module
        Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error)
}

// DefaultValidator implements the Validator interface
type DefaultValidator struct {
        schemaValidator     SchemaValidator
        dependencyValidator DependencyValidator
        resourceValidator   ResourceValidator
}

// NewValidator creates a new DefaultValidator instance
func NewValidator() *DefaultValidator <span class="cov1" title="1">{
        return &amp;DefaultValidator{
                schemaValidator:     NewSchemaValidator(),
                dependencyValidator: NewDependencyValidator(),
                resourceValidator:   NewResourceValidator(),
        }
}</span>

// Validate performs all validation checks on a module
func (v *DefaultValidator) Validate(ctx context.Context, mod *module.Module) (*ValidationResult, error) <span class="cov10" title="2">{
        result := &amp;ValidationResult{
                Valid:  true,
                Errors: make([]ValidationError, 0),
        }

        // Perform schema validation
        schemaResult, err := v.schemaValidator.Validate(ctx, mod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2">if !schemaResult.Valid </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, schemaResult.Errors...)
        }</span>

        // Perform dependency validation
        <span class="cov10" title="2">depResult, err := v.dependencyValidator.Validate(ctx, mod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2">if !depResult.Valid </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, depResult.Errors...)
        }</span>

        // Perform resource validation
        <span class="cov10" title="2">resResult, err := v.resourceValidator.Validate(ctx, mod)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2">if !resResult.Valid </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, resResult.Errors...)
        }</span>

        <span class="cov10" title="2">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package version

import (
        "fmt"
        "sort"

        "github.com/Masterminds/semver/v3"
        "github.com/StackCatalyst/common-lib/pkg/module"
)

// Manager handles version control operations for modules
type Manager interface {
        // Parse parses a version string into a Version object
        Parse(version string) (*Version, error)

        // Resolve resolves a version constraint to a specific version
        Resolve(constraint string, versions []string) (string, error)

        // Lock marks a module version as immutable
        Lock(module *module.Module) error

        // Verify verifies module integrity and signature
        Verify(module *module.Module) error

        // Compare compares two versions
        Compare(v1, v2 string) (int, error)

        // IsValid checks if a version string is valid
        IsValid(version string) bool

        // IsSatisfied checks if a version satisfies a constraint
        IsSatisfied(version, constraint string) (bool, error)
}

// Version represents a semantic version
type Version struct {
        *semver.Version
}

// DefaultManager is the default implementation of Manager
type DefaultManager struct{}

// NewManager creates a new version manager
func NewManager() Manager <span class="cov5" title="9">{
        return &amp;DefaultManager{}
}</span>

// Parse parses a version string into a Version object
func (m *DefaultManager) Parse(version string) (*Version, error) <span class="cov4" title="6">{
        v, err := semver.NewVersion(version)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid version format: %w", err)
        }</span>
        <span class="cov4" title="4">return &amp;Version{Version: v}, nil</span>
}

// Resolve resolves a version constraint to a specific version
func (m *DefaultManager) Resolve(constraint string, versions []string) (string, error) <span class="cov4" title="5">{
        c, err := semver.NewConstraint(constraint)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("invalid constraint format: %w", err)
        }</span>

        <span class="cov4" title="4">var semvers []*semver.Version
        for _, v := range versions </span><span class="cov7" title="24">{
                sv, err := semver.NewVersion(v)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid versions
                }
                <span class="cov7" title="24">semvers = append(semvers, sv)</span>
        }

        // Sort versions in descending order
        <span class="cov4" title="4">sort.Slice(semvers, func(i, j int) bool </span><span class="cov10" title="60">{
                return semvers[i].GreaterThan(semvers[j])
        }</span>)

        // Find the highest version that satisfies the constraint
        <span class="cov4" title="4">for _, sv := range semvers </span><span class="cov6" title="10">{
                if c.Check(sv) </span><span class="cov3" title="3">{
                        return sv.String(), nil
                }</span>
        }

        <span class="cov1" title="1">return "", fmt.Errorf("no version satisfies constraint %s", constraint)</span>
}

// Lock marks a module version as immutable
func (m *DefaultManager) Lock(module *module.Module) error <span class="cov0" title="0">{
        if !m.IsValid(module.Version) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid version format: %s", module.Version)
        }</span>
        // The actual locking is handled by the storage layer
        <span class="cov0" title="0">return nil</span>
}

// Verify verifies module integrity and signature
func (m *DefaultManager) Verify(module *module.Module) error <span class="cov3" title="3">{
        if !m.IsValid(module.Version) </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid version format: %s", module.Version)
        }</span>

        // Verify dependencies
        <span class="cov2" title="2">for _, dep := range module.Dependencies </span><span class="cov2" title="2">{
                if !m.IsValid(dep.Version) </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid dependency version format: %s", dep.Version)
                }</span>
        }

        // TODO: Implement signature verification
        <span class="cov1" title="1">return nil</span>
}

// Compare compares two versions
func (m *DefaultManager) Compare(v1, v2 string) (int, error) <span class="cov4" title="5">{
        sv1, err := semver.NewVersion(v1)
        if err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("invalid version format for v1: %w", err)
        }</span>

        <span class="cov4" title="4">sv2, err := semver.NewVersion(v2)
        if err != nil </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("invalid version format for v2: %w", err)
        }</span>

        <span class="cov3" title="3">return sv1.Compare(sv2), nil</span>
}

// IsValid checks if a version string is valid
func (m *DefaultManager) IsValid(version string) bool <span class="cov7" title="19">{
        _, err := semver.NewVersion(version)
        return err == nil
}</span>

// IsSatisfied checks if a version satisfies a constraint
func (m *DefaultManager) IsSatisfied(version, constraint string) (bool, error) <span class="cov6" title="12">{
        v, err := semver.NewVersion(version)
        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("invalid version format: %w", err)
        }</span>

        <span class="cov6" title="11">c, err := semver.NewConstraint(constraint)
        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("invalid constraint format: %w", err)
        }</span>

        <span class="cov6" title="10">return c.Check(v), nil</span>
}

// String returns the string representation of a Version
func (v *Version) String() string <span class="cov3" title="3">{
        return v.Version.String()
}</span>

// IsPrerelease checks if the version is a prerelease
func (v *Version) IsPrerelease() bool <span class="cov1" title="1">{
        return v.Version.Prerelease() != ""
}</span>

// Major returns the major version
func (v *Version) Major() uint64 <span class="cov1" title="1">{
        return v.Version.Major()
}</span>

// Minor returns the minor version
func (v *Version) Minor() uint64 <span class="cov1" title="1">{
        return v.Version.Minor()
}</span>

// Patch returns the patch version
func (v *Version) Patch() uint64 <span class="cov1" title="1">{
        return v.Version.Patch()
}</span>

// Prerelease returns the prerelease version
func (v *Version) Prerelease() string <span class="cov1" title="1">{
        return v.Version.Prerelease()
}</span>

// Metadata returns the metadata
func (v *Version) Metadata() string <span class="cov1" title="1">{
        return v.Version.Metadata()
}</span>

// Original returns the original version string
func (v *Version) Original() string <span class="cov1" title="1">{
        return v.Version.Original()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package testing

import (
        "context"
        "fmt"
        "time"

        "github.com/docker/go-connections/nat"
        "github.com/testcontainers/testcontainers-go"
        "github.com/testcontainers/testcontainers-go/wait"
)

// ContainerConfig holds configuration for a test container
type ContainerConfig struct {
        // Image is the Docker image to use
        Image string
        // Tag is the image tag to use
        Tag string
        // Env is a map of environment variables
        Env map[string]string
        // Ports is a map of container ports to expose
        Ports map[string]string
        // Command is the command to run in the container
        Command []string
        // Entrypoint is the entrypoint to use
        Entrypoint []string
        // WaitStrategy is the strategy to wait for container readiness
        WaitStrategy wait.Strategy
        // StartupTimeout is the maximum time to wait for container startup
        StartupTimeout time.Duration
}

// Container represents a test container
type Container struct {
        container testcontainers.Container
        config    ContainerConfig
}

// NewContainer creates a new test container
func NewContainer(ctx context.Context, config ContainerConfig) (*Container, error) <span class="cov9" title="8">{
        if config.StartupTimeout == 0 </span><span class="cov8" title="7">{
                config.StartupTimeout = 60 * time.Second
        }</span>

        <span class="cov9" title="8">req := testcontainers.GenericContainerRequest{
                ContainerRequest: testcontainers.ContainerRequest{
                        Image:      fmt.Sprintf("%s:%s", config.Image, config.Tag),
                        Env:        config.Env,
                        Cmd:        config.Command,
                        Entrypoint: config.Entrypoint,
                        WaitingFor: config.WaitStrategy,
                },
                Started: true,
        }

        // Convert ports map to exposed ports
        exposedPorts := make([]string, 0)
        for containerPort, hostPort := range config.Ports </span><span class="cov10" title="9">{
                if hostPort == "" </span><span class="cov9" title="8">{
                        exposedPorts = append(exposedPorts, containerPort)
                }</span> else<span class="cov1" title="1"> {
                        exposedPorts = append(exposedPorts, fmt.Sprintf("%s:%s", hostPort, containerPort))
                }</span>
        }
        <span class="cov9" title="8">req.ContainerRequest.ExposedPorts = exposedPorts

        container, err := testcontainers.GenericContainer(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create container: %w", err)
        }</span>

        <span class="cov9" title="8">return &amp;Container{
                container: container,
                config:    config,
        }, nil</span>
}

// GetHostPort returns the host port for a given container port
func (c *Container) GetHostPort(ctx context.Context, containerPort string) (string, error) <span class="cov8" title="7">{
        mappedPort, err := c.container.MappedPort(ctx, nat.Port(containerPort))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get mapped port: %w", err)
        }</span>
        <span class="cov8" title="7">return mappedPort.Port(), nil</span>
}

// GetHost returns the host where the container is running
func (c *Container) GetHost(ctx context.Context) (string, error) <span class="cov8" title="7">{
        return c.container.Host(ctx)
}</span>

// Stop stops the container
func (c *Container) Stop(ctx context.Context) error <span class="cov9" title="8">{
        return c.container.Terminate(ctx)
}</span>

// PostgresConfig holds PostgreSQL specific configuration
type PostgresConfig struct {
        Database string
        User     string
        Password string
        Version  string // e.g., "14-alpine", "15-alpine"
        Port     string // defaults to 5432/tcp
}

// PostgresContainer creates a PostgreSQL test container
func PostgresContainer(ctx context.Context, config PostgresConfig) (*Container, error) <span class="cov3" title="2">{
        if config.Version == "" </span><span class="cov1" title="1">{
                config.Version = "16-alpine"
        }</span>
        <span class="cov3" title="2">if config.Port == "" </span><span class="cov1" title="1">{
                config.Port = "5432/tcp"
        }</span>
        <span class="cov3" title="2">if config.Database == "" </span><span class="cov1" title="1">{
                config.Database = "test"
        }</span>
        <span class="cov3" title="2">if config.User == "" </span><span class="cov1" title="1">{
                config.User = "test"
        }</span>
        <span class="cov3" title="2">if config.Password == "" </span><span class="cov1" title="1">{
                config.Password = "test"
        }</span>

        <span class="cov3" title="2">containerConfig := ContainerConfig{
                Image: "postgres",
                Tag:   config.Version,
                Env: map[string]string{
                        "POSTGRES_DB":       config.Database,
                        "POSTGRES_USER":     config.User,
                        "POSTGRES_PASSWORD": config.Password,
                },
                Ports: map[string]string{
                        config.Port: "",
                },
                WaitStrategy: wait.ForLog("database system is ready to accept connections"),
        }

        return NewContainer(ctx, containerConfig)</span>
}

// RedisContainer creates a Redis test container
func RedisContainer(ctx context.Context) (*Container, error) <span class="cov1" title="1">{
        config := ContainerConfig{
                Image: "redis",
                Tag:   "6-alpine",
                Ports: map[string]string{
                        "6379/tcp": "",
                },
                WaitStrategy: wait.ForLog("Ready to accept connections"),
        }
        return NewContainer(ctx, config)
}</span>

// LocalstackContainer creates a Localstack test container
func LocalstackContainer(ctx context.Context, services []string) (*Container, error) <span class="cov1" title="1">{
        config := ContainerConfig{
                Image: "localstack/localstack",
                Tag:   "latest",
                Env: map[string]string{
                        "SERVICES":       "s3,dynamodb",
                        "DEFAULT_REGION": "us-east-1",
                },
                Ports: map[string]string{
                        "4566/tcp": "",
                },
                WaitStrategy: wait.ForLog("Ready."),
        }
        return NewContainer(ctx, config)
}</span>

// KafkaConfig holds Kafka specific configuration
type KafkaConfig struct {
        Version    string // e.g., "3.5", "3.6"
        BrokerPort string // defaults to 9092/tcp
        Topics     []string
        Partitions int
        Replicas   int
        ExternalIP string // for advertised listeners
}

// KafkaContainer creates a Kafka test container with KRaft mode
func KafkaContainer(ctx context.Context, config KafkaConfig) (*Container, error) <span class="cov3" title="2">{
        if config.Version == "" </span><span class="cov1" title="1">{
                config.Version = "7.5.1"
        }</span>
        <span class="cov3" title="2">if config.BrokerPort == "" </span><span class="cov1" title="1">{
                config.BrokerPort = "9092/tcp"
        }</span>
        <span class="cov3" title="2">if config.Partitions == 0 </span><span class="cov1" title="1">{
                config.Partitions = 1
        }</span>
        <span class="cov3" title="2">if config.Replicas == 0 </span><span class="cov1" title="1">{
                config.Replicas = 1
        }</span>
        <span class="cov3" title="2">if config.ExternalIP == "" </span><span class="cov1" title="1">{
                config.ExternalIP = "localhost"
        }</span>

        <span class="cov3" title="2">containerConfig := ContainerConfig{
                Image: "confluentinc/cp-kafka",
                Tag:   config.Version,
                Env: map[string]string{
                        "KAFKA_NODE_ID":                                  "1",
                        "KAFKA_CONTROLLER_QUORUM_VOTERS":                 "1@localhost:9093",
                        "KAFKA_PROCESS_ROLES":                            "broker,controller",
                        "KAFKA_CONTROLLER_LISTENER_NAMES":                "CONTROLLER",
                        "KAFKA_LISTENERS":                                "PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093",
                        "KAFKA_ADVERTISED_LISTENERS":                     "PLAINTEXT://localhost:9092",
                        "KAFKA_LISTENER_SECURITY_PROTOCOL_MAP":           "CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT",
                        "KAFKA_INTER_BROKER_LISTENER_NAME":               "PLAINTEXT",
                        "KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR":         "1",
                        "KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS":         "0",
                        "KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR": "1",
                        "KAFKA_AUTO_CREATE_TOPICS_ENABLE":                "true",
                        "CLUSTER_ID":                                     "MkU3OEVBNTcwNTJENDM2Qk",
                },
                Ports: map[string]string{
                        "9092/tcp": "",
                        "9093/tcp": "",
                },
                WaitStrategy: wait.ForLog("[KafkaRaftServer nodeId=1] Kafka Server started"),
        }

        return NewContainer(ctx, containerConfig)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package testing

import (
        "os"
        "path/filepath"
        "testing"

        "github.com/stretchr/testify/require"
)

// Helper provides utility functions for testing
type Helper struct {
        t *testing.T
        // cleanup functions to be called when the test ends
        cleanup []func()
        // tempDirs holds paths to temporary directories created during the test
        tempDirs []string
}

// NewHelper creates a new test helper
func NewHelper(t *testing.T) *Helper <span class="cov3" title="2">{
        h := &amp;Helper{
                t:       t,
                cleanup: make([]func(), 0),
        }

        // Register cleanup function to run when the test ends
        t.Cleanup(h.Cleanup)
        return h
}</span>

// Cleanup runs all registered cleanup functions in reverse order
func (h *Helper) Cleanup() <span class="cov6" title="4">{
        // Run cleanup functions in reverse order
        for i := len(h.cleanup) - 1; i &gt;= 0; i-- </span><span class="cov10" title="12">{
                h.cleanup[i]()
        }</span>

        // Clean up temporary directories
        <span class="cov6" title="4">for _, dir := range h.tempDirs </span><span class="cov7" title="6">{
                os.RemoveAll(dir)
        }</span>
}

// AddCleanup adds a cleanup function to be called when the test ends
func (h *Helper) AddCleanup(fn func()) <span class="cov7" title="6">{
        h.cleanup = append(h.cleanup, fn)
}</span>

// TempDir creates a new temporary directory and registers it for cleanup
func (h *Helper) TempDir() string <span class="cov4" title="3">{
        dir, err := os.MkdirTemp("", "test-*")
        require.NoError(h.t, err)
        h.tempDirs = append(h.tempDirs, dir)
        return dir
}</span>

// TempFile creates a new temporary file and registers it for cleanup
func (h *Helper) TempFile(dir, pattern string) *os.File <span class="cov1" title="1">{
        f, err := os.CreateTemp(dir, pattern)
        require.NoError(h.t, err)
        h.AddCleanup(func() </span><span class="cov3" title="2">{
                f.Close()
                os.Remove(f.Name())
        }</span>)
        <span class="cov1" title="1">return f</span>
}

// WriteFile writes data to a file and registers it for cleanup
func (h *Helper) WriteFile(path string, data []byte, perm os.FileMode) <span class="cov1" title="1">{
        err := os.MkdirAll(filepath.Dir(path), 0755)
        require.NoError(h.t, err)
        err = os.WriteFile(path, data, perm)
        require.NoError(h.t, err)
        h.AddCleanup(func() </span><span class="cov3" title="2">{
                os.Remove(path)
        }</span>)
}

// RequireNoError asserts that err is nil
func (h *Helper) RequireNoError(err error, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.NoError(h.t, err, msgAndArgs...)
}</span>

// RequireError asserts that err is not nil
func (h *Helper) RequireError(err error, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.Error(h.t, err, msgAndArgs...)
}</span>

// RequireEqual asserts that expected and actual are equal
func (h *Helper) RequireEqual(expected, actual interface{}, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.Equal(h.t, expected, actual, msgAndArgs...)
}</span>

// RequireNotEqual asserts that expected and actual are not equal
func (h *Helper) RequireNotEqual(expected, actual interface{}, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.NotEqual(h.t, expected, actual, msgAndArgs...)
}</span>

// RequireTrue asserts that value is true
func (h *Helper) RequireTrue(value bool, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.True(h.t, value, msgAndArgs...)
}</span>

// RequireFalse asserts that value is false
func (h *Helper) RequireFalse(value bool, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.False(h.t, value, msgAndArgs...)
}</span>

// RequireNil asserts that object is nil
func (h *Helper) RequireNil(object interface{}, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.Nil(h.t, object, msgAndArgs...)
}</span>

// RequireNotNil asserts that object is not nil
func (h *Helper) RequireNotNil(object interface{}, msgAndArgs ...interface{}) <span class="cov1" title="1">{
        require.NotNil(h.t, object, msgAndArgs...)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package tracing

import (
        "fmt"
        "net/http"
        "time"

        "github.com/opentracing/opentracing-go"
        "github.com/opentracing/opentracing-go/ext"
)

// HTTPMiddleware creates middleware for tracing HTTP requests
func HTTPMiddleware(tracer *Tracer) func(http.Handler) http.Handler <span class="cov4" title="2">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="2">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov4" title="2">{
                        // Try to extract span context from headers
                        spanCtx, err := tracer.Extract(
                                opentracing.HTTPHeaders,
                                opentracing.HTTPHeadersCarrier(r.Header),
                        )

                        // Start the span
                        var span opentracing.Span
                        if err != nil </span><span class="cov4" title="2">{
                                // No span context in headers, create a new one
                                span = tracer.StartSpan(fmt.Sprintf("%s %s", r.Method, r.URL.Path))
                        }</span> else<span class="cov0" title="0"> {
                                // Create span as child of extracted context
                                span = tracer.StartSpan(
                                        fmt.Sprintf("%s %s", r.Method, r.URL.Path),
                                        ext.RPCServerOption(spanCtx),
                                )
                        }</span>
                        <span class="cov4" title="2">defer span.Finish()

                        // Set standard HTTP tags
                        ext.HTTPMethod.Set(span, r.Method)
                        ext.HTTPUrl.Set(span, r.URL.String())
                        ext.Component.Set(span, "http")

                        // Add request-specific tags
                        span.SetTag("http.remote_addr", r.RemoteAddr)
                        span.SetTag("http.user_agent", r.UserAgent())
                        if reqID := r.Header.Get("X-Request-ID"); reqID != "" </span><span class="cov1" title="1">{
                                span.SetTag("http.request_id", reqID)
                        }</span>

                        // Create wrapped response writer to capture status code
                        <span class="cov4" title="2">wrapped := wrapResponseWriter(w)

                        // Add span to request context
                        ctx := opentracing.ContextWithSpan(r.Context(), span)
                        r = r.WithContext(ctx)

                        // Record timing
                        start := time.Now()

                        // Call next handler
                        next.ServeHTTP(wrapped, r)

                        // Add response tags
                        duration := time.Since(start)
                        span.SetTag("http.status_code", wrapped.status)
                        span.SetTag("http.duration_ms", float64(duration.Milliseconds()))

                        // Mark error if status &gt;= 500
                        if wrapped.status &gt;= http.StatusInternalServerError </span><span class="cov1" title="1">{
                                ext.Error.Set(span, true)
                                span.SetTag("error.type", "server_error")
                        }</span>
                })
        }
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        status      int
        wroteHeader bool
}

func wrapResponseWriter(w http.ResponseWriter) *responseWriter <span class="cov10" title="5">{
        return &amp;responseWriter{ResponseWriter: w}
}</span>

func (rw *responseWriter) Status() int <span class="cov7" title="3">{
        return rw.status
}</span>

func (rw *responseWriter) WriteHeader(code int) <span class="cov10" title="5">{
        if !rw.wroteHeader </span><span class="cov10" title="5">{
                rw.status = code
                rw.wroteHeader = true
                rw.ResponseWriter.WriteHeader(code)
        }</span>
}

func (rw *responseWriter) Write(b []byte) (int, error) <span class="cov7" title="3">{
        if !rw.wroteHeader </span><span class="cov1" title="1">{
                rw.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov7" title="3">return rw.ResponseWriter.Write(b)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package tracing

import (
        "context"
        "fmt"
        "io"

        "github.com/opentracing/opentracing-go"
        "github.com/uber/jaeger-client-go"
        "github.com/uber/jaeger-client-go/config"
        "github.com/uber/jaeger-lib/metrics/prometheus"
)

// Config holds the configuration for the tracer
type Config struct {
        // ServiceName is the name of the service
        ServiceName string
        // AgentHost is the host of the Jaeger agent
        AgentHost string
        // AgentPort is the port of the Jaeger agent
        AgentPort string
        // Enabled determines if tracing is enabled
        Enabled bool
        // SamplingRate is the rate at which traces are sampled (0.0 to 1.0)
        SamplingRate float64
        // Tags are additional tags to add to all spans
        Tags map[string]string
}

// DefaultConfig returns the default tracer configuration
func DefaultConfig() Config <span class="cov8" title="6">{
        return Config{
                ServiceName:  "service",
                AgentHost:    "localhost",
                AgentPort:    "6831",
                Enabled:      true,
                SamplingRate: 0.1,
                Tags:         make(map[string]string),
        }
}</span>

// Tracer manages the distributed tracing functionality
type Tracer struct {
        tracer opentracing.Tracer
        closer io.Closer
        config Config
}

// New creates a new tracer
func New(cfg Config) (*Tracer, error) <span class="cov4" title="2">{
        if !cfg.Enabled </span><span class="cov1" title="1">{
                return &amp;Tracer{
                        tracer: opentracing.NoopTracer{},
                        config: cfg,
                }, nil
        }</span>

        <span class="cov1" title="1">jcfg := &amp;config.Configuration{
                ServiceName: cfg.ServiceName,
                Sampler: &amp;config.SamplerConfig{
                        Type:  jaeger.SamplerTypeConst,
                        Param: cfg.SamplingRate,
                },
                Reporter: &amp;config.ReporterConfig{
                        LocalAgentHostPort: fmt.Sprintf("%s:%s", cfg.AgentHost, cfg.AgentPort),
                },
                Tags: []opentracing.Tag{
                        {Key: "service.version", Value: "1.0.0"},
                        {Key: "environment", Value: "production"},
                },
        }

        // Add custom tags
        for k, v := range cfg.Tags </span><span class="cov0" title="0">{
                jcfg.Tags = append(jcfg.Tags, opentracing.Tag{Key: k, Value: v})
        }</span>

        // Initialize metrics factory
        <span class="cov1" title="1">metricsFactory := prometheus.New()

        // Initialize tracer
        tracer, closer, err := jcfg.NewTracer(
                config.Metrics(metricsFactory),
                config.Logger(jaeger.StdLogger),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create tracer: %w", err)
        }</span>

        // Set as global tracer
        <span class="cov1" title="1">opentracing.SetGlobalTracer(tracer)

        return &amp;Tracer{
                tracer: tracer,
                closer: closer,
                config: cfg,
        }, nil</span>
}

// StartSpan starts a new span
func (t *Tracer) StartSpan(name string, opts ...opentracing.StartSpanOption) opentracing.Span <span class="cov10" title="8">{
        return t.tracer.StartSpan(name, opts...)
}</span>

// StartSpanFromContext starts a new span from a context
func (t *Tracer) StartSpanFromContext(ctx context.Context, name string, opts ...opentracing.StartSpanOption) (opentracing.Span, context.Context) <span class="cov5" title="3">{
        if parentSpan := opentracing.SpanFromContext(ctx); parentSpan != nil </span><span class="cov1" title="1">{
                opts = append(opts, opentracing.ChildOf(parentSpan.Context()))
        }</span>
        <span class="cov5" title="3">span := t.StartSpan(name, opts...)
        return span, opentracing.ContextWithSpan(ctx, span)</span>
}

// Inject injects span context into carrier
func (t *Tracer) Inject(ctx context.Context, format interface{}, carrier interface{}) error <span class="cov0" title="0">{
        span := opentracing.SpanFromContext(ctx)
        if span == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no span in context")
        }</span>
        <span class="cov0" title="0">return t.tracer.Inject(span.Context(), format, carrier)</span>
}

// Extract extracts span context from carrier
func (t *Tracer) Extract(format interface{}, carrier interface{}) (opentracing.SpanContext, error) <span class="cov5" title="3">{
        return t.tracer.Extract(format, carrier)
}</span>

// Close closes the tracer
func (t *Tracer) Close() error <span class="cov4" title="2">{
        if t.closer != nil </span><span class="cov1" title="1">{
                return t.closer.Close()
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// WithField adds a field to the span in context
func WithField(ctx context.Context, key string, value interface{}) <span class="cov4" title="2">{
        if span := opentracing.SpanFromContext(ctx); span != nil </span><span class="cov4" title="2">{
                span.SetTag(key, value)
        }</span>
}

// WithError adds an error to the span in context
func WithError(ctx context.Context, err error) <span class="cov1" title="1">{
        if span := opentracing.SpanFromContext(ctx); span != nil </span><span class="cov1" title="1">{
                span.SetTag("error", true)
                span.SetTag("error.message", err.Error())
        }</span>
}

// WithFields adds multiple fields to the span in context
func WithFields(ctx context.Context, fields map[string]interface{}) <span class="cov1" title="1">{
        if span := opentracing.SpanFromContext(ctx); span != nil </span><span class="cov1" title="1">{
                for k, v := range fields </span><span class="cov4" title="2">{
                        span.SetTag(k, v)
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
